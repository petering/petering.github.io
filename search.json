[{"title":"Hello World","url":"/2022/04/11/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"java中的HashMap","url":"/2022/04/11/java-hashMap/","content":"HashMap hashMap= new HashMap();hashMap.add(null,null);\n\n","categories":["java collection"],"tags":["HashMap"]},{"title":"my first blog","url":"/2022/04/11/my-first-blog/","content":""},{"title":"jvm体系结构","url":"/2022/04/11/jvm%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","content":"\n\n\nJVM所处的位置\n\n\n\n从上图中我们可以看出，JVM是运行在操作系统之上的，它与硬件没有直接的交互，但凡JVM想要调用硬件的一些操作，它就得通过操作系统。\n\n\n\n\n\n\n","categories":["jvm"],"tags":["JVM"]},{"title":"java中的volatile关键字","url":"/2022/04/12/java_volatile/","content":"\n\nJava volatile关键字分析目录\n一、简介\n二、并发编程3大基本概念\n三、锁的互斥性和可见性\n四、Java的内存模型 JMM 以及共享变量的可见性\n五、volatile变量的特性\n六、volatile适用的场景\n七、volatile原理\n\n一、简介​\t\tvolatile 是Java提供的一种轻量级的同步机制。Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量，相比于synchronized（synchronized通常称为重量级锁），volatile更轻量级，因为它不会引起线程上下文的切换和调度。但是volatile 变量的同步性较差（有时它更简单并且开销更低），而且其使用也更容易出错。\n​\t\t计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。\n　　也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：\ni = i + 1；\n\n当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。\n　　这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。\n　　比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？\n　　可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。\n　　最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。\n　　也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。\n　　为了解决缓存不一致性问题，通常来说有以下2种解决方法：\n　　1）通过在总线加LOCK#锁的方式\n　　2）通过缓存一致性协议\n　　这2种方式都是硬件层面上提供的方式。\n　　在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i &#x3D; i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。\n　　但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。\n　　所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。\n\n二、并发编程3大基本概念原子性，可见性，有序性\n1.原子性\n原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。\n　　一个很经典的例子就是银行账户转账问题：\n　　比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。\n　　试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。\n　　所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。\n　　同样地反映到并发编程中会出现什么结果呢？\n　　举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？\ni = 9;\n\n 　假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。\n　　那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。\n2.可见性\n　　可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。\n　　举个简单的例子，看下面这段代码：\n//线程1执行的代码int i = 0;i = 10;//线程2执行的代码j = i;\n\n 　假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i &#x3D;10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。\n　　此时线程2执行 j &#x3D; i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.\n　　这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。\n3.有序性\n　　有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：\nint i =  0;       boolean flag = false ;i = 1;         //语句1 flag = true;   //语句2\n\n 　上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。\n　　下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。\n　　比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。\n　　但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：\nint a = 10;  //语句1int r = 2;  //语句2a = a + 3;  //语句3r = a*a;   //语句4\n\n 　这段代码有4个语句，那么可能的一个执行顺序是：　\n　　那么可不可能是这个执行顺序呢： 语句2  语句1  语句4  语句3\n　　不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。\n　　虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：\n//线程1:context = loadContext();  //语句1inited = true;       //语句2//线程2:while(!inited )&#123; \tsleep()&#125;doSomethingwithconfig(context);\n\n 　上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。\n 　从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。\n　　也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。\n三、锁的互斥性和可见性锁提供了两种主要特性：互斥（mutual exclusion） 和可见性（visibility）。\n（1）互斥即一次只允许一个线程持有某个特定的锁，一次就只有一个线程能够使用该共享数据。\n（2）可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的。也即当一条线程修改了共享变量的值，新值对于其他线程来说是可以立即得知的。如果没有同步机制提供的这种可见性保证，线程看到的共享变  量可能是修改前的值或不一致的值，这将引发许多严重问题。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：\n​\ta.对变量的写操作不依赖于当前值。\n​\tb.该变量没有包含在具有其他变量的不变式中。\n​\t\t实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。事实上就是保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。\n四、Java的内存模型 JMM 以及共享变量的可见性​\t\t JMM决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory），本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。\n\n​\t\t对于普通的共享变量来讲，线程A将其修改为某个值发生在线程A的本地内存中，此时还未同步到主内存中去；而线程B已经缓存了该变量的旧值，所以就导致了共享变量值的不一致。解决这种共享变量在多线程模型中的不可见性问题，较粗暴的方式自然就是加锁，但是此处使用synchronized或者Lock这些方式太重量级了，比较合理的方式其实就是volatile。\n五、volatile变量的特性1.保证可见性，不保证原子性  （1）当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去；\n  （2）这个写会操作会导致其他线程中的volatile变量缓存无效。\n 2.禁止指令重排    重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。重排序需要遵守一定规则：\n （1）重排序操作不会对存在数据依赖关系的操作进行重排序。\n　 比如：a&#x3D;1;b&#x3D;a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。\n （2）重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变\n　 比如：a&#x3D;1;b&#x3D;2;c&#x3D;a+b这三个操作，第一步（a&#x3D;1)和第二步(b&#x3D;2)由于不存在数据依赖关系， 所以可能会发生重排序，但是c&#x3D;a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c&#x3D;a+b&#x3D;3。\n​\t\t重排序在单线程下一定能保证结果的正确性，但是在多线程环境下，可能发生重排序，影响结果，下例中的1和2由于不存在数据依赖关系，则有可能会被重排序，先执行status&#x3D;true再执行a&#x3D;2。而此时线程B会顺利到达4处，而线程A中a&#x3D;2这个操作还未被执行，所以b&#x3D;a+1的结果也有可能依然等于2。\npublic class TestVolatile&#123;int a = 1;boolean status = false;//状态切换为truepublic void changeStatus&#123;a = 2;   //1status = true;  //2&#125;//若状态为true，则为runningpublic void run()&#123;\tif(status)&#123;   //3\tint b = a + 1;  //4\tSystem.out.println(b);\t\t&#125;\t&#125;&#125;\n\n     使用volatile关键字修饰共享变量便可以禁止这种重排序。若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序,volatile禁止指令重排序也有一些规则：\n\n​\t\ta.当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；​\t\tb.在进行指令优化时，不能将对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。​\t\t即执行到volatile变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对volatile变量及其后面语句可见。\n3.volatile的原理和实现机制\n　　前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。\n　　下面这段话摘自《深入理解Java虚拟机》：\n　　“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”\n　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：\n　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；\n　　2）它会强制将对缓存的修改操作立即写入主存；\n　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。\n六、volatile适用的场景​\t\tsynchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：\n　　1）对变量的写操作不依赖于当前值\n　　2）该变量没有包含在具有其他变量的不变式中\n　　实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。\n　　事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。\n　　下面列举几个Java中使用volatile的几个场景。\n1.状态标记量\nvolatile boolean flag = false; while(!flag)&#123;    doSomething();&#125; public void setFlag() &#123;    flag = true;&#125;\n\n\n\nvolatile boolean inited = false;//线程1:context = loadContext();  inited = true;             //线程2:while(!inited )&#123;sleep()&#125;doSomethingwithconfig(context);\n\n2.double check\nclass Singleton&#123;    private volatile static Singleton instance = null;         private Singleton() &#123;             &#125;         public static Singleton getInstance() &#123;        if(instance==null) &#123;            synchronized (Singleton.class) &#123;                if(instance==null)                    instance = new Singleton();            &#125;        &#125;        return instance;    &#125;&#125;\n\n七、volatile原理​\t\tvolatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：\n（1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；\n（2）它会强制将对缓存的修改操作立即写入主存；\n（3）如果是写操作，它会导致其他CPU中对应的缓存行无效。\n\n","categories":["java"],"tags":["Java","并发编程JUC","volatile"]}]