[{"title":"java中的HashMap","url":"/2022/04/11/java-hashMap/","content":"HashMap hashMap= new HashMap();hashMap.add(null,null);\n\n","categories":["java collection"],"tags":["HashMap"]},{"title":"Hello World","url":"/2022/04/11/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"jvm体系结构","url":"/2022/04/11/jvm%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","content":"\n\n\nJVM所处的位置\n\n\n\n从上图中我们可以看出，JVM是运行在操作系统之上的，它与硬件没有直接的交互，但凡JVM想要调用硬件的一些操作，它就得通过操作系统。\n\n\n\n\n\n\n","categories":["jvm"],"tags":["JVM"]},{"title":"my first blog","url":"/2022/04/11/my-first-blog/","content":""},{"title":"java并发编程JUC","url":"/2022/04/13/java_juc/","content":"\n\n1、什么是JUC\n回顾：Runnable接口与Callable接口：\n\ncallable的核心是call方法，允许返回值，runnable的核心是run方法，没有返回值\n\ncallable和runnable都可以应用于executors。而thread类只支持runnable\n\n\n2、进程和线程一个进程可以包含多个线程，Java默认线程数：2个， main 和 GC 。\n对于Java而言，开启线程的方式为：Thread，Runnable，Callable\n\n问题：Java真的可以开启线程吗？\n\n否，我们来看一段代码：\npublic synchronized void start() &#123;       /**        * This method is not invoked for the main method thread or &quot;system&quot;        * group threads created/set up by the VM. Any new functionality added        * to this method in the future may have to also be added to the VM.        *        * A zero status value corresponds to state &quot;NEW&quot;.        */       if (threadStatus != 0)           throw new IllegalThreadStateException();       /* Notify the group that this thread is about to be started        * so that it can be added to the group&#x27;s list of threads        * and the group&#x27;s unstarted count can be decremented. */       group.add(this);       boolean started = false;       try &#123;           start0();           started = true;       &#125; finally &#123;           try &#123;               if (!started) &#123;                   group.threadStartFailed(this);               &#125;           &#125; catch (Throwable ignore) &#123;               /* do nothing. If start0 threw a Throwable then                 it will be passed up the call stack */           &#125;       &#125;   &#125;//本地方法，底层调用C++,Java无法直接硬件操作   private native void start0();\n\n\n并发，并行\n\n并发：多线程操作同一资源\n\n单CPU，线程间快速切换\n\n并行：\n\n多CPU，多线程同时进行\n\npublic class test &#123;    public static void main(String[] args) &#123;        //获取CPU核数        System.out.println(Runtime.getRuntime().availableProcessors());    &#125;&#125;\n\n线程有哪几个状态？\npublic enum State &#123;    //新生    NEW,    //运行    RUNNABLE,    BLOCKED,    WAITING,        //超时等待    TIMED_WAITING,    TERMINATED;&#125;\n\n\nwait&#x2F;sleep区别\n\n\n来自不同类\n\nwait &#x3D;&gt; Object\nsleep &#x3D; &gt; Thread\n\n锁的释放\n\nwait释放，wait不释放\n\n使用范围\n\nsleep可以在任何地方使用\n而wait只能用于同步代码快\n\n是否捕获异常\n\nwait不需要（&#x3D;&#x3D;但是所有线程都会捕获中断异常&#x3D;&#x3D;），而sleep必须捕获\n3、Lock锁\n传统synchronized\n\npackage juc;//多线程模拟售票（并发）public class ticketDemo &#123;    public static void main(String[] args) &#123;        Ticket ticket = new Ticket();        //并发：多线程操作同一个资源类，直接把资源丢进线程        //线程A        new Thread(()-&gt;&#123;            for (int i = 0; i &lt; 20; i++) &#123;                ticket.sale();                try &#123;                    Thread.sleep(100);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;A&quot;).start();        //线程B        new Thread(()-&gt;&#123;            for (int i = 0; i &lt; 20; i++) &#123;                ticket.sale();            &#125;        &#125;,&quot;B&quot;).start();    &#125;&#125;//资源类:属性和方法OOP//尽量不要在此处继承Runnable接口，降低耦合度class Ticket&#123;    //属性    private int num=20;    //方法    public synchronized void sale()&#123;        if(num&gt;0)        System.out.println(&quot;剩余票数为&quot; + (num--)+&quot;线程为&quot;+ Thread.currentThread().getName());    &#125;&#125;\n\n\nLock锁\n\npackage juc;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;//多线程模拟售票（并发）public class ticketDemo2 &#123;    public static void main(String[] args) &#123;        Ticket2 ticket = new Ticket2();        //并发：多线程操作同一个资源类，直接把资源丢进线程        //线程A        new Thread(()-&gt;&#123;            for (int i = 0; i &lt; 20; i++) &#123;                ticket.sale();                try &#123;                    Thread.sleep(100);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;A&quot;).start();                //线程B        new Thread(()-&gt;&#123;            for (int i = 0; i &lt; 20; i++) &#123;                ticket.sale();            &#125;        &#125;,&quot;B&quot;).start();    &#125;&#125;//Lock三部曲/** * 1.new ReentrantLock() * 2.lock.lock()加锁 * 3.finally =&gt; lock.unlock 解锁 */class Ticket2&#123;    //属性    private int num=20;   Lock lock = new ReentrantLock();    //方法    public void sale()&#123;        lock.lock();    //加锁        try &#123;        //业务代码            if (num &gt; 0)                System.out.println(&quot;剩余票数为&quot; + (num--) + &quot;线程为&quot; + Thread.currentThread().getName());        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;finally &#123;     //无论如何都要解锁            lock.unlock();        &#125;    &#125;&#125;\n\n&#x3D;&#x3D;synchronized与lock锁的区别&#x3D;&#x3D;\n\nsynchronized 内置的Java关键字，Lock是一个Java类\nsynchronized 无法判断锁的状态，lock可以判断是否获得锁\n前者自动释放锁，lock必须手动释放！如果不释放，将导致死锁！\nsynchroniezd无法获得锁将阻塞等待，lock则不会一直等待。\nsynchronized 可重入锁，不可中断，非公平，而Lock是可重入锁，可以判断锁，默认非公平（可修改）。\n\n\n可重入锁：可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。\n\n\nsynchronized适合锁少量的代码同步问题，lock适合锁大量的同步代码。\n\n&#x3D;&#x3D;锁是什么？如何判断锁是谁？&#x3D;&#x3D;\n4、生产者消费者问题三个步骤：等待 -&gt; 操作 -&gt; 通知\n\nsynchronized实现方案\nlock实现方案\n\n两者的区别是什么？\nsynchronized通过wait方法使线程阻塞，notify方法唤醒线程\n而lock则是通过await方法阻塞等待，signal唤醒，相比lock可支持定向唤醒某个线程（condition）\nCondition con1 = lock.newCondition()Condition con2 = lock.newCondition()con1.signal(); //指定唤醒\n\n注意：为防止虚假唤醒，在判断时，应当使用&#x3D;&#x3D;while&#x3D;&#x3D;\n5、八锁现象涉及到锁的八个问题。（注意同步关系）\n注意：在所有的锁中，如果是锁的对象中的某个方法或者属性，则表示对该对象加锁。\n而如果是对静态方法加锁，则表示对Class（模板）加锁，所有对静态属性或者静态方法加锁的行为都是同一把锁。\n6、CopyOnWriteArrayList(C\nArrayList的并发异常\n\nimport java.util.ArrayList;//list的并发异常ConcurrentModificationExceptionpublic class Listdemo &#123;    public static void main(String[] args) &#123;        ArrayList arrayList = new ArrayList();        for (int i = 0; i &lt; 100; i++) &#123;            new Thread(()-&gt;&#123;                arrayList.add(&quot;hello&quot;);            &#125;).start();        &#125;        System.out.println(arrayList);    &#125;&#125;\n\n\nException in thread “main” java.util.ConcurrentModificationException\n\n&#x3D;&#x3D;并发异常的解决方案：&#x3D;&#x3D;\n\n使用线程安全类Vector\n\n\nList arrayList = new Vector();\n\n\n使用工具类Collections\n\n\nList arrayList = Collections.synchronizedList(new ArrayList());\n\n\n&#x3D;&#x3D;CopyOnWriteArrayList（写入时复制）&#x3D;&#x3D;(读写分离)\n\n多个线程写入的时候，避免覆盖\n\nList arrayList = new CopyOnWriteArrayList();\n\n看底层代码：\npublic boolean add(E e) &#123;    synchronized (lock) &#123;        Object[] es = getArray();        int len = es.length;        es = Arrays.copyOf(es, len + 1);        es[len] = e;        setArray(es);        return true;    &#125;&#125;\n\n相比Vector不需要在读的时候加锁，写入时复制大大提高读取效率。（即读操作不需要进行同步）l（在开发中读比写频繁）\n看一下Vector的get方法如下\npublic synchronized E get(int index) &#123;    if (index &gt;= elementCount)        throw new ArrayIndexOutOfBoundsException(index);    return elementData(index);&#125;\n\n7、CopyOnWriteArraySetSet arraySet = new CopyOnWriteArraySet();\n\n8、ConcurrentHashMapHashMap在并发下put产生异常！\n      Map map = new HashMap();//并发HashMapMap map = new ConcurrentHashMap();      for (int i = 0; i &lt; 50; i++) &#123;          int finalI = i;          new Thread(()-&gt;&#123;              map.put(String.valueOf(finalI),&quot;world&quot;);          &#125;).start();      &#125;      System.out.println(map);  &#125;\n\n9、JUC常用辅助类1. CountDownLatch资源–\npackage juc;import java.util.concurrent.CountDownLatch;public class CountDownDemo &#123;    public static void main(String[] args) throws InterruptedException &#123;        //线程计数器        CountDownLatch countDownLatch = new CountDownLatch  (6);        for (int i = 0; i &lt; 6; i++) &#123;            int finalI = i;            new Thread(()-&gt;&#123;                countDownLatch.countDown();//计数器-1                //System.out.println(finalI);            &#125;).start();        &#125;        //判断是否归零,接着再执行下一步操作        countDownLatch.await();        System.out.println(countDownLatch.getCount());        System.out.println(&quot;close door&quot;);    &#125;&#125;\n\n2. CyclicBarrier资源++\n 线程计数器（集齐7颗龙珠触发操作）：指定个数线程执行完毕之后再执行操作\n3. Semaphere信号量同一时间只能有指定个线程执行（限流）\npackage juc;import java.util.concurrent.Semaphore;public class SemaphereDemo  &#123;    public static void main(String[] args) &#123;        //线程数量        Semaphore semaphore = new Semaphore(3);        for (int i = 0; i &lt; 5; i++) &#123;            new Thread(()-&gt;&#123;                //aquire()得到                try &#123;                    semaphore.acquire();                    System.out.println(Thread.currentThread().getName()+&quot; running&quot;);                    Thread.sleep(2000);                    System.out.println(Thread.currentThread().getName()+&quot; closed&quot;);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;finally &#123;                    semaphore.release();                &#125;            &#125;).start();        &#125;    &#125;&#125;\n\n\n原理： semaphore.acquire(); 获得，如果已满则等待\n​\t\t\tsemaphore.release(); 释放，会将当前信号量+1，然后唤醒等待线程\n\n作用：多个共享资源互斥使用，并发限流，控制最大线程数。\n10、读写锁ReadWriteLock\n11、BlockingQueue阻塞队列(接口)用处：多线程并发处理，线程池 。\n\n\n如何使用队列：\n四组API\n\n\n\n方式\n抛出异常\n有返回值，不抛出异常\n阻塞等待\n超时等待\n\n\n\n添加\nadd\noffer\nput\noffer\n\n\n移除\nremove\npoll\ntake\npoll\n\n\n检测队首\nelement\npeek\n-\n\n\n\npackage juc;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;/** * 1.抛出异常 */public class BlockDemo &#123;    public static void main(String[] args) &#123;        test1();    &#125;    public static void test1()&#123;        //队列大小        BlockingQueue blockingQueue = new ArrayBlockingQueue(2);        System.out.println(blockingQueue.add(&quot;a&quot;));        System.out.println(blockingQueue.add(&quot;b&quot;));        //System.out.println(blockingQueue.add(&quot;c&quot;));        //抛出异常IllegalStateException: Queue full        blockingQueue.remove();        blockingQueue.remove();        blockingQueue.remove();        //抛出异常NoSuchElementException    &#125;&#125;\n\n/** * 2.有返回值，不抛出异常 */public static void test2()&#123;    //队列大小    BlockingQueue blockingQueue = new ArrayBlockingQueue(2);        System.out.println(blockingQueue.offer(&quot;a&quot;));    System.out.println(blockingQueue.offer(&quot;b&quot;));    System.out.println(blockingQueue.offer(&quot;c&quot;));   //输出false             \tSystem.out.println(blockingQueue.peek());  //输出a        blockingQueue.poll();    blockingQueue.poll();    System.out.println(blockingQueue.poll());   //输出null&#125;\n\n/** *3.阻塞等待 */public static void test3() throws InterruptedException &#123;    //队列大小    BlockingQueue blockingQueue = new ArrayBlockingQueue(2);    blockingQueue.put(&quot;a&quot;);    blockingQueue.put(&quot;a&quot;);    //blockingQueue.put(&quot;a&quot;);   //阻塞等待    System.out.println(blockingQueue.take());    System.out.println(blockingQueue.take());    blockingQueue.take();  //阻塞&#125;\n\n/** *4.超时等待 */public static void test4() throws InterruptedException &#123;    //队列大小    BlockingQueue blockingQueue = new ArrayBlockingQueue(2);    blockingQueue.offer(&quot;a&quot;);    blockingQueue.offer(&quot;b&quot;);    blockingQueue.offer(&quot;c&quot;,2, TimeUnit.SECONDS);  //超时等待2秒    System.out.println(blockingQueue.poll());    System.out.println(blockingQueue.poll());    blockingQueue.poll(2,TimeUnit.SECONDS);&#125;\n\n12、同步队列SynchronousQueue（类）同步队列不存储元素，put了一个元素后，必须先take出来，否则无法put。\n13、&#x3D;&#x3D;线程池（重点）&#x3D;&#x3D;三大方法，7大参数，4种拒绝策略\n\n池化技术：事先准备好一些资源，有需要则来拿，用完还回去。\n\n程序运行的本质：占用系统资源！优化资源的使用！&#x3D;&gt;池化技术\n线程池、连接池、内存池….\n默认大小：2\n线程池好处：\n\n降低资源的消耗\n提高响应速度（不需要创建和销毁等浪费时间的操作）\n方便管理\n\n&#x3D;&#x3D;线程复用，控制最大并发数，管理线程&#x3D;&#x3D;\n\n3大方法\n\npackage juc;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;//Excutors 工具类、3大方法public class PoolDemo &#123;    public static void main(String[] args) &#123;        ExecutorService executorService = Executors.newSingleThreadExecutor();   //单个线程        ExecutorService executorService1 = Executors.newFixedThreadPool(5);  //创建一个固定线程池大小        ExecutorService executorService2 = Executors.newCachedThreadPool();   //可伸缩的线程池        //开启线程(使用线程池创建线程)      try &#123;          for (int i = 0; i &lt; 100; i++) &#123;              executorService1.execute(()-&gt;&#123;                  System.out.println(Thread.currentThread().getName()+&quot;已启动！&quot;);              &#125;);          &#125;      &#125;catch (Exception e)&#123;          e.printStackTrace();      &#125;finally &#123;          executorService1.shutdown();  //保证线程池用完关闭      &#125;    &#125;&#125;\n\n\n7大参数\n\n先来看看三大方法的源码：\n//方法一：创建单个线程public static ExecutorService newSingleThreadExecutor() &#123;    return new FinalizableDelegatedExecutorService        (new ThreadPoolExecutor(1, 1,                                0L, TimeUnit.MILLISECONDS,                                new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;//方法二：创建固定线程池大小public static ExecutorService newFixedThreadPool(int nThreads) &#123;    return new ThreadPoolExecutor(nThreads, nThreads,                                  0L, TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue&lt;Runnable&gt;());&#125;//方法三public static ExecutorService newCachedThreadPool() &#123;    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;());&#125;\n\n本质上：上述三种方法底层都是调用&#x3D;&#x3D;ThreadPoolExecutor&#x3D;&#x3D;方法！\n因此，我们来看看ThreadPoolExecutor方法：\npublic ThreadPoolExecutor(int corePoolSize,   //核心线程池大小（当前可用线程）                          int maximumPoolSize, //最大线程池大小                          long keepAliveTime,  //存活时间（线程最大等待时间）                          TimeUnit unit,       //存活时间单位                          BlockingQueue&lt;Runnable&gt; workQueue) &#123;   //阻塞队列    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,         Executors.defaultThreadFactory(), defaultHandler);   //线程工厂和拒绝策略（4种策略）&#125;\n\n阿里开发守则之并发：\n\n接下来我们看一下&#x3D;&#x3D;四大拒绝策略&#x3D;&#x3D;：\nnew ThreadPoolExecutor.AbortPolicy());//队列满了，最大线程为8，此时抛出RejectedExecutionException异常new ThreadPoolExecutor().DiscardPolicy()); //队列满，丢掉任务，不抛出异常new ThreadPoolExecutor().DiscardOldestPolicy()); //队列满，尝试和最早的线程竞争，竞争成功执行，失败丢弃不抛出异常new ThreadPoolExecutor().CallerRunsPolicy()); //哪来的去哪里，由调用线程处理\n\npackage juc;import java.util.concurrent.*;//Excutors 工具类、3大方法public class PoolDemo &#123;    public static void main(String[] args) &#123;        //自定义线程池        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(                2,                5,                3,                TimeUnit.SECONDS,                new ArrayBlockingQueue(3),   //最大承载线程为队列长度+最大线程池                Executors.defaultThreadFactory(),                new ThreadPoolExecutor.AbortPolicy());//队列满了，最大线程为8，此时抛出RejectedExecutionException异常                // new ThreadPoolExecutor().DiscardPolicy()); //队列满，丢掉任务，不抛出异常                //new ThreadPoolExecutor().DiscardOldestPolicy()); //队列满，尝试和最早的线程竞争，竞争成功执行，失败丢弃不抛出异常                //new ThreadPoolExecutor().CallerRunsPolicy()); //哪来的去哪里，由调用线程处理        //开启线程(使用线程池创建线程)      try &#123;          for (int i = 0; i &lt; 9; i++) &#123;              threadPoolExecutor.execute(()-&gt;&#123;                  System.out.println(Thread.currentThread().getName()+&quot;已启动！&quot;);              &#125;);          &#125;      &#125;catch (Exception e)&#123;          e.printStackTrace();      &#125;finally &#123;          threadPoolExecutor.shutdown();  //保证线程池用完关闭      &#125;    &#125;&#125;\n\n\n&#x3D;&#x3D;最大的线程池大小maximumPoolSize如何设置？&#x3D;&#x3D;\n\nCPU密集型与IO密集型\nmaximumPoolSize //最大线程池大小    1.CPU密集型，=CPU核数    2.IO密集型，&gt;IO任务线程数        Runtime.getRuntime().availableProcessors();  //获取处理器核数\n\n14、四大函数式接口（必须掌握）（java.util.function）新时代程序员必会：lambda表达式、链式编程、函数式接口、Stream流式计算\n（旧时代程序员：泛型、枚举、反射）\n\n函数式接口：只有一个方法的接口\n​\t作用：简化编程模型，在新版本的框架底层大量应用\n\n  @FunctionalInterfacepublic interface Runnable &#123;    public abstract void run();&#125;\n\n\n&#x3D;&#x3D;函数型接口&#x3D;&#x3D;\n\n\n\npackage juc;import java.util.function.Function;/** * 1.Function函数式接口 * 只要是函数式接口，都可用lambda表达式简化 */public class InterfaceDemo &#123;    public static void main(String[] args) &#123;        Function function = new Function&lt;String,String&gt;()&#123;            @Override            public String  apply(String o) &#123;                return o;            &#125;        &#125;;        //lambda表达式        Function function1 = str-&gt;&#123;            return str;        &#125;;        System.out.println(function.apply(&quot;hello&quot;));        System.out.println(function1.apply(&quot;world&quot;));    &#125;&#125;\n\n\n&#x3D;&#x3D;断定型接口&#x3D;&#x3D;\n\n@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123;    boolean test(T t);\n\n\n\npackage juc;import java.util.function.Predicate;public class PredictedDemo &#123;    public static void main(String[] args) &#123;        Predicate&lt;String&gt; predicate = new Predicate&lt;&gt;() &#123;            @Override            public boolean test(String s) &#123;                return s.isEmpty();            &#125;        &#125;;        //用lambda表达式简化        Predicate&lt;String&gt; predicate1 = str-&gt;&#123;            return str.isEmpty();        &#125;;        System.out.println(predicate.test(&quot;hello&quot;));        System.out.println(predicate1.test(&quot;hello&quot;));    &#125;&#125;\n\n\n&#x3D;&#x3D;消费型接口&#x3D;&#x3D;\n\n@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123;    void accept(T t);\n\n\n\npackage juc;import java.util.function.Consumer;/** * 3.消费型接口 * 只有一个输入参数 */public class ConsumerDemo  &#123;    public static void main(String[] args) &#123;        Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() &#123;            @Override            public void accept(String s) &#123;                System.out.println(s);            &#125;        &#125;;        //lambda表达式        Consumer&lt;String&gt; consumer1 = str-&gt;&#123;            System.out.println(str);        &#125;;        consumer.accept(&quot;hello&quot;);        consumer1.accept(&quot;world&quot;);    &#125;&#125;\n\n\n&#x3D;&#x3D;供给型接口&#x3D;&#x3D;\n\n@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123;    T get();\t//只有返回值类型，没有输入参数&#125;\n\npackage juc;import java.util.function.Supplier;/** * 4.供给型接口 * 没有输出参数，只有返回值 */public class SupplierDemo &#123;    public static void main(String[] args) &#123;        Supplier&lt;String&gt; stringSupplier = new Supplier&lt;String&gt;()&#123;            @Override            public String get() &#123;                return &quot;hello&quot;;            &#125;        &#125;;        //lambda表达式        Supplier&lt;String&gt; supplier = ()-&gt;&#123;            return &quot;world&quot;;        &#125;;        System.out.println(stringSupplier.get());        System.out.println(supplier.get());    &#125;&#125;\n\n15、JMMJava内存模型，是不存在的东西，只是概念和约定！\n例如：\n\n线程解锁前，必须把共享变量立刻刷回主存。\n线程加锁前，必须读取主存中的最新值到工内存。\n加锁和解锁是同一把锁。\n\npackage juc;public class JMMDemo &#123;    private static int num=0;    public static void main(String[] args)&#123;        new Thread(()-&gt;&#123;            while (num ==0)&#123;   //线程永远无法停止            &#125;        &#125;).start();        num=1;        System.out.println(num);        System.out.println(Thread.activeCount());    &#125;&#125;\n\n\n16、Volatile三大特性：\n\n可见性\n非原子性\n禁止指令重排(内存屏障)\n\n17、单例模式\n饿汉式\n\n//单例模式（饿汉式）public class Hungry &#123;    //构造方式为私有    private Hungry()&#123;    &#125;    private final static Hungry HUNGRY = new Hungry();  //已经生成了对象（饿汉式）    public static Hungry getInstance()&#123;        return HUNGRY;    &#125;&#125;\n\n\nDCL懒汉式\n\n package juc.singleDemo;public class LazyMan &#123;    private LazyMan()&#123;    &#125;    private volatile static LazyMan lazyMan;  //为何加volatile？防止指令重排    //双重检测，防止多线程产生问题    public static LazyMan getInstance()&#123;        if(lazyMan==null)&#123;            synchronized (LazyMan.class)&#123;   //锁住类Class，防止多线程创建对象                if(lazyMan==null)&#123;                    lazyMan= new LazyMan();    //不是一个原子操作，可能发生指令重排                    /**                     * 1.分配内存空间                     * 2.执行构造方法                     * 3.把对象指向该空间                     * 123顺序执行没问题，但如果132在第二步时进入第二个线程则会直接返回lazyMan，此时对象还未完成构造                     */                &#125;            &#125;        &#125;        return lazyMan;    &#125;&#125;\n\n18、CAS(与乐观锁原理相同)compareAndSet：比较当前工作内存中的值和主内存中的值，如果是期望值那么执行操作否则一直循环。\n缺点：\n1、循环耗时\n2、一次性只能保证一个共享变量的原子性\n3、ABA问题\npackage juc.singleDemo;import java.util.concurrent.atomic.AtomicInteger;public class CASDemmo &#123;    public static void main(String[] args) &#123;        AtomicInteger atomicInteger = new AtomicInteger(2022);        System.out.println(atomicInteger.get());        System.out.println(atomicInteger.getAndIncrement());        System.out.println(atomicInteger.compareAndSet(2022, 2023));   //false        System.out.println(atomicInteger.get());    &#125;&#125;\n\n\n  **&#x3D;&#x3D;CAS的ABA问题&#x3D;&#x3D;**：如果改变的是基本类型则没影响，但是如果改变的是引用类型，由于Java是值传递，虽然传递的值不变，但可能引用的对象已经发生改变。\n如何解决？原子引用！（带版本号的原子操作）\n19、java的Integer比较\n**&#x3D;&#x3D;注意&#x3D;&#x3D;**：&#x3D;&#x3D;所有相同类型的包装类对象之间的值比较，应该使用equals方法比较。&#x3D;&#x3D;–来自阿里巴巴java开发手册。\n\n例：\npublic static void main(String[] args)throws Exception&#123;    Integer a = -121;    Integer b = -121;    Integer c = 345;    Integer d = 345;    System.out.println(a.equals(b));    System.out.println(a == b);    System.out.println(c.equals(d));    System.out.println(c == d);&#125;\n\n打印结果为：\ntruetruetruefalse\n\nc和d的值都是345,为什么用&#x3D;&#x3D;和equals比较结果不一样呢？\n我们看下对象信息，注意对象地址：\n\n\nInteger值的比较有个坑：对于Integer var &#x3D; ?,&#x3D;&#x3D;在-128至127范围内的赋值， Integer 对象是在IntegerCache.cache 产生，会复用已有对象&#x3D;&#x3D;，这个区间内的 Integer 值可以直接使用&#x3D;&#x3D;进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象;所以，在上面，我们的c和d两个，虽然值是一样的，但是地址不一样。\n这是一个大坑，很多人会在项目中使用&#x3D;&#x3D;来比较Integer！强烈建议，必须使用equals来比较！\n20、可重入锁（递归锁）\n在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁\n\n也即是说，线程可以进入任何一个它已经拥有的锁所同步着的代码块\n\n\npackage juc.Lock;//可重入锁public class Demo01 &#123;    public static void main(String[] args) &#123;        Phone phone = new Phone();        //线程A        new Thread(()-&gt;&#123;            phone.call();        &#125;,&quot;A&quot;).start();        //线程B        new Thread(()-&gt;&#123;            phone.call();        &#125;,&quot;B&quot;).start();    &#125;&#125;class Phone&#123;    public synchronized void call()&#123;           System.out.println(Thread.currentThread().getName()+&quot;call&quot;);        send();   //这里也有锁，此处自动获得内层的锁    &#125;    public synchronized void send()&#123;        System.out.println(Thread.currentThread().getName()+&quot;send&quot;);    &#125;&#125;输出：AcallAsendBcallBsend\n\n","categories":["java"],"tags":["java","juc","并发编程"]},{"title":"java中的volatile关键字","url":"/2022/04/12/java_volatile/","content":"\n\nJava volatile关键字分析目录\n一、简介\n二、并发编程3大基本概念\n三、锁的互斥性和可见性\n四、Java的内存模型 JMM 以及共享变量的可见性\n五、volatile变量的特性\n六、volatile适用的场景\n七、volatile原理\n\n一、简介​\t\tvolatile 是Java提供的一种轻量级的同步机制。Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量，相比于synchronized（synchronized通常称为重量级锁），volatile更轻量级，因为它不会引起线程上下文的切换和调度。但是volatile 变量的同步性较差（有时它更简单并且开销更低），而且其使用也更容易出错。\n​\t\t计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。\n　　也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：\ni = i + 1；\n\n当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。\n　　这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。\n　　比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？\n　　可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。\n　　最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。\n　　也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。\n　　为了解决缓存不一致性问题，通常来说有以下2种解决方法：\n　　1）通过在总线加LOCK#锁的方式\n　　2）通过缓存一致性协议\n　　这2种方式都是硬件层面上提供的方式。\n　　在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i &#x3D; i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。\n　　但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。\n　　所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。\n\n二、并发编程3大基本概念原子性，可见性，有序性\n1.原子性\n原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。\n　　一个很经典的例子就是银行账户转账问题：\n　　比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。\n　　试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。\n　　所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。\n　　同样地反映到并发编程中会出现什么结果呢？\n　　举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？\ni = 9;\n\n 　假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。\n　　那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。\n2.可见性\n　　可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。\n　　举个简单的例子，看下面这段代码：\n//线程1执行的代码int i = 0;i = 10;//线程2执行的代码j = i;\n\n 　假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i &#x3D;10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。\n　　此时线程2执行 j &#x3D; i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.\n　　这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。\n3.有序性\n　　有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：\nint i =  0;       boolean flag = false ;i = 1;         //语句1 flag = true;   //语句2\n\n 　上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。\n　　下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。\n　　比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。\n　　但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：\nint a = 10;  //语句1int r = 2;  //语句2a = a + 3;  //语句3r = a*a;   //语句4\n\n 　这段代码有4个语句，那么可能的一个执行顺序是：　\n　　那么可不可能是这个执行顺序呢： 语句2  语句1  语句4  语句3\n　　不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。\n　　虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：\n//线程1:context = loadContext();  //语句1inited = true;       //语句2//线程2:while(!inited )&#123; \tsleep()&#125;doSomethingwithconfig(context);\n\n 　上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。\n 　从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。\n　　也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。\n三、锁的互斥性和可见性锁提供了两种主要特性：互斥（mutual exclusion） 和可见性（visibility）。\n（1）互斥即一次只允许一个线程持有某个特定的锁，一次就只有一个线程能够使用该共享数据。\n（2）可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的。也即当一条线程修改了共享变量的值，新值对于其他线程来说是可以立即得知的。如果没有同步机制提供的这种可见性保证，线程看到的共享变  量可能是修改前的值或不一致的值，这将引发许多严重问题。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：\n​\ta.对变量的写操作不依赖于当前值。\n​\tb.该变量没有包含在具有其他变量的不变式中。\n​\t\t实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。事实上就是保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。\n四、Java的内存模型 JMM 以及共享变量的可见性​\t\t JMM决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory），本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。\n\n​\t\t对于普通的共享变量来讲，线程A将其修改为某个值发生在线程A的本地内存中，此时还未同步到主内存中去；而线程B已经缓存了该变量的旧值，所以就导致了共享变量值的不一致。解决这种共享变量在多线程模型中的不可见性问题，较粗暴的方式自然就是加锁，但是此处使用synchronized或者Lock这些方式太重量级了，比较合理的方式其实就是volatile。\n五、volatile变量的特性1.保证可见性，不保证原子性  （1）当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去；\n  （2）这个写会操作会导致其他线程中的volatile变量缓存无效。\n 2.禁止指令重排    重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。重排序需要遵守一定规则：\n （1）重排序操作不会对存在数据依赖关系的操作进行重排序。\n　 比如：a&#x3D;1;b&#x3D;a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。\n （2）重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变\n　 比如：a&#x3D;1;b&#x3D;2;c&#x3D;a+b这三个操作，第一步（a&#x3D;1)和第二步(b&#x3D;2)由于不存在数据依赖关系， 所以可能会发生重排序，但是c&#x3D;a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c&#x3D;a+b&#x3D;3。\n​\t\t重排序在单线程下一定能保证结果的正确性，但是在多线程环境下，可能发生重排序，影响结果，下例中的1和2由于不存在数据依赖关系，则有可能会被重排序，先执行status&#x3D;true再执行a&#x3D;2。而此时线程B会顺利到达4处，而线程A中a&#x3D;2这个操作还未被执行，所以b&#x3D;a+1的结果也有可能依然等于2。\npublic class TestVolatile&#123;int a = 1;boolean status = false;//状态切换为truepublic void changeStatus&#123;a = 2;   //1status = true;  //2&#125;//若状态为true，则为runningpublic void run()&#123;\tif(status)&#123;   //3\tint b = a + 1;  //4\tSystem.out.println(b);\t\t&#125;\t&#125;&#125;\n\n     使用volatile关键字修饰共享变量便可以禁止这种重排序。若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序,volatile禁止指令重排序也有一些规则：\n\n​\t\ta.当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；​\t\tb.在进行指令优化时，不能将对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。​\t\t即执行到volatile变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对volatile变量及其后面语句可见。\n3.volatile的原理和实现机制\n　　前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。\n　　下面这段话摘自《深入理解Java虚拟机》：\n　　“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”\n　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：\n　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；\n　　2）它会强制将对缓存的修改操作立即写入主存；\n　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。\n六、volatile适用的场景​\t\tsynchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：\n　　1）对变量的写操作不依赖于当前值\n　　2）该变量没有包含在具有其他变量的不变式中\n　　实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。\n　　事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。\n　　下面列举几个Java中使用volatile的几个场景。\n1.状态标记量\nvolatile boolean flag = false; while(!flag)&#123;    doSomething();&#125; public void setFlag() &#123;    flag = true;&#125;\n\n\n\nvolatile boolean inited = false;//线程1:context = loadContext();  inited = true;             //线程2:while(!inited )&#123;sleep()&#125;doSomethingwithconfig(context);\n\n2.double check\nclass Singleton&#123;    private volatile static Singleton instance = null;         private Singleton() &#123;             &#125;         public static Singleton getInstance() &#123;        if(instance==null) &#123;            synchronized (Singleton.class) &#123;                if(instance==null)                    instance = new Singleton();            &#125;        &#125;        return instance;    &#125;&#125;\n\n七、volatile原理​\t\tvolatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：\n（1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；\n（2）它会强制将对缓存的修改操作立即写入主存；\n（3）如果是写操作，它会导致其他CPU中对应的缓存行无效。\n\n","categories":["java"],"tags":["Java","并发编程JUC","volatile"]}]