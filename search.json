[{"title":"Hello World","url":"/2022/04/11/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"java中的HashMap","url":"/2022/04/11/java-hashMap/","content":"HashMap hashMap= new HashMap();hashMap.add(null,null);\n\n","categories":["java collection"],"tags":["HashMap"]},{"title":"javaWeb文件上传","url":"/2022/04/12/java_uploadFile/","content":"\n\nJavaWeb文件上传关注原理，拿来即用文件以流的形式提交到服务器。\n依赖包：(注意手动添加依赖包方法)\n&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-io&lt;/groupId&gt;    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;    &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt;\n\n&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;    &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;\n\n注意事项：\n\n为保证服务器安全，上传文件应该放在外界无法直接访问的目录下，比如放于WEB-NF目录下。\n为防止文件覆盖的现象发生，要为上传文件产生一个唯一的文件名。（-时间戳 -uuid -md5）\n要限制上传文件的最大值。\n可以限制上传文件的类型，在收到上传文件名时，判断后缀名是否合法。\n\n登录表单：login.xml\n&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; %&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/upload.do&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;    上传用户：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt;    上传文件1：&lt;input type=&quot;file&quot; name=&quot;file1&quot;&gt;&lt;br/&gt;    上传文件2：&lt;input type=&quot;file&quot; name=&quot;file2&quot;&gt;&lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\nServlet\npackage com.pans.servlet;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.FileUploadException;import org.apache.commons.fileupload.ProgressListener;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.*;import java.util.List;import java.util.UUID;public class UploadFileServlet extends HttpServlet &#123;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        doGet(request, response);    &#125;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        try &#123;            //判断上传的文件是普通的表单还是带文件的表单            if (!ServletFileUpload.isMultipartContent(request)) &#123;                return;//如果是普通文件，我们可以直接返回            &#125; //如果通过了这个if，说明我们的表单是带文件上传的；            //创建上传文件的保存路径，建议在WEB-INF路径下，安全，用户无法直接访问上传的文件；            String uploadPath = this.getServletContext().getRealPath(&quot;/WEB-INF/upload&quot;);            File uploadFile = new File(uploadPath);            if (!uploadFile.exists()) &#123;//如果目录不存在，创建这样一个目录；                uploadFile.mkdir();            &#125;            //临时路径，假如文件超过了预期的大小，我们就把他放到一个临时文件中，过几天自动删除，或者提醒用户转存为永久            String tmpPath = this.getServletContext().getRealPath(&quot;/WEB-INF/tmp&quot;);            File file = new File(tmpPath);            if (!file.exists()) &#123;//如果目录不存在，创建这样一个目录；                file.mkdir();            &#125;            //处理上传的文件，一般都需要通过流来获取，我们可以使用request.getInputStream(),原生态的文件上传流获取，十分麻烦            //但是我们都建议使用 Apache的文件上传组件来实现，common-fileupload，它需要依赖于 commons-io组件；            //1.创建DiskFileItemFactory对象，处理文件上传路径或者大小限制的；            DiskFileItemFactory factory = getDiskFileItemFactory(file);            //2.获取ServletFileUpload            ServletFileUpload upload = getServletFileUpload(factory);            //3.处理上传的文件            String msg = uploadParseRequest(upload, request, uploadPath);            //servlet请求转发消息            request.setAttribute(&quot;msg&quot;,msg);            request.getRequestDispatcher(&quot;info.jsp&quot;).forward(request,response);        &#125; catch (FileUploadException e) &#123;            e.printStackTrace();        &#125;    &#125;    public static DiskFileItemFactory getDiskFileItemFactory(File file) &#123;        DiskFileItemFactory factory = new DiskFileItemFactory();        //通过这个工厂设置一个缓冲区，当上传的文件大于这个缓冲区的时候，将他放到临时文件中；        factory.setSizeThreshold(1024 * 1024); //缓存区大小为1M        factory.setRepository(file);//临时目录的保存目录，需要一个File        return factory;    &#125;    public static ServletFileUpload getServletFileUpload(DiskFileItemFactory factory) &#123;        ServletFileUpload upload = new ServletFileUpload(factory);        //监听文件上传进度；        upload.setProgressListener(new ProgressListener() &#123;            @Override            //pBytesRead:已经读取到的文件大小            //pContentLength ： 文件大小            public void update(long pBytesRead, long pContentLength, int pItems) &#123;                System.out.println(&quot;总大小：&quot; + pContentLength + &quot;已上传：&quot; + pBytesRead);            &#125;        &#125;);        //处理乱码问题        upload.setHeaderEncoding(&quot;UTF-8&quot;);        //设置单个文件的最大值        upload.setFileSizeMax(1024 * 1024 * 10);        //设置总共能够上传文件的大小        //1024 = 1kb * 1024 = 1M * 10 = 10M        upload.setSizeMax(1024 * 1024 * 10);        return upload;    &#125;    public static String uploadParseRequest(ServletFileUpload upload,HttpServletRequest request,String uploadPath)            throws FileUploadException, IOException &#123;        String msg = &quot;&quot;;        //3.把前端请求解析，封装成一个FileItem对象        List&lt;FileItem&gt; fileItems = upload.parseRequest(request);        for (FileItem fileItem : fileItems) &#123;            if (fileItem.isFormField())&#123; //判断上传的文件是普通的表单还是带文件的表单                //getFieldName指的是前端表单控件的name；                String name = fileItem.getFieldName();                String value = fileItem.getString(&quot;UTF-8&quot;); //处理乱码                System.out.println(name+&quot;:&quot;+value);            &#125;else &#123; //判断它是上传的文件                //=======================处理文件===============================//                //拿到文件名字                String uploadFileName = fileItem.getName();                System.out.println(&quot;上传的文件名：&quot;+uploadFileName);                if (uploadFileName.trim().equals(&quot;&quot;)||uploadFileName==null)&#123;                    continue;                &#125;                //获得上传的文件名  /images/girl/paojie.png                String fileName = uploadFileName.substring(uploadFileName.lastIndexOf(&quot;/&quot;) + 1);                //获得文件的后缀名                String fileExtName = uploadFileName.substring(uploadFileName.lastIndexOf(&quot;.&quot;) + 1);                    /*                        如果文件后缀名 fileExtName 不是我们所需要的                        就直接return，不处理，告诉用户文件类型不对。                    */                System.out.println(&quot;文件信息 [件名：&quot;+fileName+&quot;---文件类型&quot;+fileExtName+&quot;]&quot;);                //可以使用UUID（唯一识别的通用码），保证文件名唯一；                //UUID.randomUUID()，随机生一个唯一识别的通用码；                String uuidPath = UUID.randomUUID().toString();                //=======================处理文件完毕===============================//                //存到哪？ uploadPath                //文件真实存在的路径 realPath                String realPath =   uploadPath+&quot;/&quot;+uuidPath;                //给每个文件创建一个对应的文件夹                File realPathFile = new File(realPath);                if (!realPathFile.exists())&#123;                    realPathFile.mkdir();                &#125;                //=======================存放地址完毕===============================//                //获得文件上传的流                InputStream inputStream = fileItem.getInputStream();                //创建一个文件输出流                //realPath = 真实的文件夹；                //差了一个文件; 加上输出文件的名字+&quot;/&quot;+uuidFileName                FileOutputStream fos = new FileOutputStream(realPath+&quot;/&quot;+fileName);                //创建一个缓冲区                byte[] buffer = new byte[1024*1024];                //判断是否读取完毕                int len = 0;                //如果大于0说明还存在数据；                while ((len=inputStream.read(buffer))&gt;0)&#123;                    fos.write(buffer,0,len);                &#125;                //关闭流                fos.close();                inputStream.close();                msg = &quot;文件上传成功！&quot;;                fileItem.delete(); //上传成功，清除临时文件                //=======================文件传输完毕===============================//            &#125;        &#125;        return msg;    &#125;&#125;\n","categories":["java"],"tags":["javaweb","文件上传"]},{"title":"Java Web","url":"/2022/04/20/java_web/","content":"\n\nJava Web1、基本概念\n静态web：html、css等文件，提供的数据是静态的（所有人看到的都是一样）\n\n无法和数据库交互（数据无法持久化）\n\n\n动态web：看到的数据时刻发生变化\n\n技术栈：Serverlet&#x2F;JSP、(微软ASP）\n\n\n\n\n在java中方，动态web资源开发技术统称为JavaWeb\n\nweb应用程序：可供浏览器访问的程序\nweb应用组成：\nhtml、css、js\njsp、serverlet\njava程序\njar包\n配置文件（properties）\n\n\n\n\n\n2、web服务器2.1 技术栈\nASP（微软）：最早，页面混乱，维护成本高\nPHP：开发速度快，功能强，跨平台，代码简单（WP），无法承载大访问量\nJSP&#x2F;Serverlet：B&#x2F;S浏览器服务器架构，可承载三高问题，基于Java\n\n2.2 Tomcat&#x3D;&#x3D;注意：&#x3D;&#x3D;启动前先配置好java环境变量，tomcat环境变量，否则会闪退！\n\n配置：server.xml\n\n改端口：\n\n&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;           connectionTimeout=&quot;20000&quot;           redirectPort=&quot;8443&quot; /&gt;\n\n\n改主机名localhost（127.0.0.1）：\n\n&lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;  //网站存放应用位置webapps      unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;\n\n2.3 发布web网站基于Tomcat的网站结构：\n--webapps :Tomcat的web目录\t-ROOT\t-xxx   //网站目录名\t\t-WEB-INF\t\t\t-classes \t//java程序\t\t\t-lib\t\t//java应用所依赖的jar包\t\t\t-web.xml\t//网站配置文件\t\t-index.xml //默认首页\t\t-static\t\t\t-css\t\t\t\t-style.css\t\t\t-js\t\t\t-img    \t-.....\n\n\n\n3、Maven包管理工具。\n\n核心思想：约定大于配置！\n\n下载安装—&gt;配置环境变量—-&gt;更改配置文件（镜像地址和本地仓库地址）\n4、&#x3D;&#x3D;IDEA中的Maven&#x3D;&#x3D;!!!!注意：IDEA版本和Maven的版本要适配，2021版的idea勿用maven3.8！！！（3.6.3可用）\n 新建maven项目时发现archetype很少—-&gt;先关闭当前项目，再新建项目，则会加载很多模板！\n\n新建的mavenweb文件结构如下：\n\n\n\n\nIDEA标记文件夹功能\n\n\n\n\n\n&#x3D;&#x3D;未来可能遇到的问题：&#x3D;&#x3D;由于maven的约定大配置，我们之后可能遇到我们的配置文件，无法被导出或者生效的问题\n&#x3D;&#x3D;解决方案：&#x3D;&#x3D;在pom.xml中加入如下配置文件：\n&lt;build&gt;      &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/resources&lt;/directory&gt;            &lt;excludes&gt;                &lt;exclude&gt;**/*.properties&lt;/exclude&gt;                &lt;exclude&gt;**/*.xml&lt;/exclude&gt;             &lt;/excludes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;  //关闭过滤，确保配置文件被导出        &lt;/resource&gt;    &lt;/resources&gt;&lt;/build&gt;\n\n5、Maven仓库的使用地址：https://mvnrepository.com/\n6、Servlet6.1 Servlet简介\nsun公司开发动态web的一门技术\n\n开发Servlet只需要完成如下两个步骤：\n1. 编写一个类，实现Servlet接口\n1. 把开发好的Java类部署到web服务器中\n\n把实现了Servlet接口的Java程序叫做：Servlet\n6.2 构建Servlet步骤：\n\n构建一个普通的Maven项目，删掉src目录，将该工程作为主工程（Maven父子工程）\n\n\n\n父项目中ppom.xml新增以下内容：\n&lt;modules&gt;    &lt;module&gt;servlet01&lt;/module&gt;&lt;/modules&gt;\n\n父项目中的jar包子项目可以直接使用，反之不可 \n\nmaven环境：\n\n\n修改web.xml为最新（可以在tomcat里面找到）\n\n将maven的web结构设置好\n\n编写Servlet接口实现类，继承HttpServlet\n\n\npackage com.pans.servlet;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class HelloServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;       // ServletOutputStream outputStream = resp.getOutputStream();        PrintWriter writer = resp.getWriter();   //响应流        writer.print(&quot;hello servlet!&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doGet(req, resp);    &#125;&#125;\n\n\n编写Servlet映射\n\n为何需要映射：我们写的java程序，需要通过浏览器访问，而浏览器需要链接web服务器，所以需要在web服务器中注册我们的Servlet！\n&lt;!--注册Servlet--&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.pans.servlet.HelloServlet&lt;/servlet-class&gt;  &lt;/servlet&gt;&lt;!--映射路径--&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;  //名字要一致    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;\n\n\n配置Tomcat\n\n注意项目发布路径\n\n\n\n启动\n\n在访问编写的java文件路径时出现了一个问题：\n\n\n经过百度发现时Tomcat10之后包名不再是”javax.servlet”,则是改为”jakarta.servlet”\n解决方案时：\n\nTomcat版本改为10以下的版本\n“javax.servlet”改为”jakarta.servlet”\n\n&lt;dependency&gt;  &lt;groupId&gt;jakarta.servlet.jsp&lt;/groupId&gt;  &lt;artifactId&gt;jakarta.servlet.jsp-api&lt;/artifactId&gt;  &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt;  &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt;  &lt;version&gt;5.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--类中的导入部分也需要更改import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;--&gt;\n\n6.3 Servlet原理\n6.4 Servlet 的Mapping&lt;!--映射路径--&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;  //名字要一致    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;\n\n\n一个Servlet可以指定一个映射路径\n一个Servlet可以指定多个映射路径\n一个Servlet可以指定通用映射路径\n指定后缀或者前缀等。。\n\n注意：指定的固有映射路径优先级大于默认路径。\n6.5 ServletContextweb容器在启动的时候，它会为每个web程序创建一个对应的ServletContext对象，它代表当前web应用；（类似Context是个全局对象，为所有Servlet共享（一个Servlet对应一个映射路径））\n作用：（几乎都会被替代）\n\n共享数据（会被Session或者request替代）\n获取初始化参数\n请求转发（由request替代）\n读取资源文件（由类加载或者反射来实现）\n\n6.6 HttpServletResponse应用：\n\n下载文件\n验证码功能\n重定向！！（一定要注意路径问题）\n\nexample：登录界面重定向\n\n\nindex.jsp\n&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World!&lt;/h2&gt;&lt;%@ page pageEncoding=&quot;UTF-8&quot; %&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/login&quot; method=&quot;post&quot;&gt;    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;    密码： &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\nlogin\npackage com.pans.servlet;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;public class login extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot;进入此方法！&quot;);        String username = req.getParameter(&quot;username&quot;);        String password = req.getParameter(&quot;password&quot;);        System.out.println(username+&quot;:&quot;+password);        //重定向登录成功页面        resp.sendRedirect(&quot;/s1/success.jsp&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doGet(req, resp);    &#125;&#125;\n\nsuccess.jsp\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;success!!!!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\n\n6.7 HttpServletRequest7、Cookie、Session客户端 服务端\n\n服务端给客户端一个信件，客户端下次访问时带上信件（cookie）\n\n服务端登记你来过，下次你来我匹配你（session）\n\n\n7.1 保存会话的两种技术cookie：保存在客户端\n\n客户端技术\n\nsession：存储在服务端\n\n服务器技术，可以保存用户的会话信息，把信息或者会话放在Session中\n\n应用：用户登录状态\n\n从请求中拿到cookie\n服务器响应给客户端cookie\n\nCookie[] cookies = req.getCookies();  //获得cookiecookie.getName();  //获得cooKie的keycookie.getValue();  //获得cooKie的valueCookie cookie = new Cookie(&quot;name&quot;,&quot;peter&quot;);  //创建一个cookie（key,value）resp.addCookie(cookie);    //给客户的响应cookie(间接设置客户端cookie)\n\n7.2 &#x3D;&#x3D;Session（重点）&#x3D;&#x3D;\n服务器为每一个用户（浏览器）创建一个Session对象\n一个Session独占一个浏览器，只要浏览器没关，Session就存在\n\nCookie与Session区别：\n\nCookie是把用户的数据写到用户浏览器，浏览器保存（可以多个）\nSession 把用户的数据写到用户独占Session中，服务器端保存\nSession对象由服务器创建\n\n使用场景：\n\n保存一个登录用户信息\n购物车信息\n在整个网站中中经常会使用的数据，保存在Session中\n\n8、JSP（Java Server Page服务器端页面）和Servlet一样用于开发动态页面。\n在IDEA编写的jsp文件，可以去IDEA中的工作目录下的tomcat找到当前工作项目，发现jsp底层仍然是java文件：\n\n\n因此，jsp本质上就是servlet。\n浏览器向服务器发送请求，不管在访问什么资源（文件），其实都是在访问Servlet！\n9、JavaBean实体类\nJavaBean特有写法：\n\n必须要有一个无参构造\n属性必须私有\n必须有对应的get&#x2F;set方法\n\n一般用来和数据库的字段做映射：&#x3D;&#x3D;ORM&#x3D;&#x3D;\nORM：对象关系映射\n\n表—&gt;类\n字段—&gt;属性\n行记录—-&gt;对象\n\n10、MVC三层架构Model（模型） View（视图） Controller（控制器）\n\nModel\n\n业务处理：业务逻辑（Service）\n数据持久层：CRUD（DAO）\n\nView\n\n展示数据\n提供链接发起Servlet请求\n\nController（Sevlet）\n\n接收用户请求：（req:请求参数，Session信息）\n交给业务层处理对应的代码\n控制视图跳转\n\n登录---&gt;接收用户登录请求----&gt;处理请求（获取用户参数）----&gt;交给业务层处理登录业务（判断用户）----&gt;Dao层查询用户名密码-----&gt;查数据库\n11、&#x3D;&#x3D;Filter过滤器&#x3D;&#x3D;用于过滤网站数据（乱码，过滤文字，权限拦截）\n添加过滤器步骤：\n\n导入相关依赖（pom.xml）\n编写过滤器，实现（implements）Filter接口里面的方法\n在web.xml中配置过滤器（和sevlet类似）\n\n&lt;filter&gt;  &lt;filter-name&gt;CharactorFilter&lt;/filter-name&gt;  &lt;filter-class&gt;com.pans.servlet.login&lt;/filter-class&gt;   //login为实现Filter的类&lt;/filter&gt;&lt;filter-mapping&gt;  &lt;filter-name&gt;CharactorFilter&lt;/filter-name&gt;  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  //需要过滤的网站&lt;/filter-mapping&gt;\n\n12、监听器  编写监听器方法，pom.xml注册监听器\n13、JDBC&#x3D;&#x3D;项目中实践。。。未完待续。。。&#x3D;&#x3D;\n","categories":["javaweb"],"tags":["java","web"]},{"title":"my first blog","url":"/2022/04/11/my-first-blog/","content":""},{"title":"jvm体系结构","url":"/2022/04/11/jvm%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","content":"\n\n\nJVM所处的位置\n\n\n\n从上图中我们可以看出，JVM是运行在操作系统之上的，它与硬件没有直接的交互，但凡JVM想要调用硬件的一些操作，它就得通过操作系统。\n\n\n\n\n\n\n","categories":["jvm"],"tags":["JVM"]},{"title":"Mybatis","url":"/2022/05/02/Mybatis/","content":"\n\nMybatis1、简介1.1 什么是Mybatis\n\nMyBatis 是一款优秀的持久层框架\n它支持自定义 SQL、存储过程以及高级映射。\nMyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。\nMyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\n\n&lt;dependency&gt;  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;  &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;\n\n1.2 持久层数据持久化\n\n将程序的数据在持久态和瞬时状态转换。（数据库，io）\n\n持久层：\n\n完成持久化工作的代码块\n\n2、Mybatis程序示例步骤：环境搭建—–&gt;导入依赖—-&gt;编码\n2.1 搭建环境导入依赖\n\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.5.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;8.0.21&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n2.2 创建子项目&#x2F;模块\n编写Mybatis核心配置文件\n\nmybatis-config.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                                                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;serverTimezone=Asia/Shanghai&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;                                            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;com/pans/dao/UserMapper.xml&quot;/&gt;   //注意添加dao映射关系    &lt;/mappers&gt;&lt;/configuration&gt;\n\n\n编写Mybatis工具类（连接数据库）\n\nMybatisUtils\npackage com.pans.utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MybatisUtils &#123;    private static SqlSessionFactory sqlSessionFactory;//    static&#123;//        try &#123;//            String resource = &quot;mybatis-config.xml&quot;;//            InputStream inputStream = null;//            inputStream = Resources.getResourceAsStream(resource);//            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);//        &#125; catch (IOException e) &#123;//            e.printStackTrace();//        &#125;//////    &#125;    public static SqlSession getSqlSession()&#123;        try &#123;            String resource = &quot;mybatis-config.xml&quot;;            InputStream inputStream = null;            inputStream = Resources.getResourceAsStream(resource);            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return sqlSessionFactory.openSession();    &#125;&#125;\n\n\nDao接口\n\npackage com.pans.dao;import com.pans.pojo.User;import java.util.List;public interface UserDao &#123;    public List&lt;User&gt; getUserList();&#125;\n\n\n&#x3D;&#x3D;接口实现&#x3D;&#x3D;\n\n由原来的实现类变成xml文件UserMapper.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.pans.dao.UserDao&quot;&gt;         &lt;select id=&quot;getUserList&quot; resultType=&quot;com.pans.pojo.User&quot;&gt;        select * from mybatis.user    &lt;/select&gt;&lt;/mapper&gt;\n\n&#x3D;&#x3D;注意：&#x3D;&#x3D;\nnamespace: 表示需要实现的接口类\nid: 需要实现的接口类里面的方法\n**resultType:**方法的返回类型\nparameterType：方法的参数类型\n\n测试类\n\npackage com.pans.dao;import com.pans.pojo.User;import com.pans.utils.MybatisUtils;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.List;public class UserDaoTest &#123;    @Test    public void test()&#123;        //第一步：获取sqlSession对象        SqlSession sqlSession = MybatisUtils.getSqlSession();        //执行SQL        UserDao mapper = sqlSession.getMapper(UserDao.class);        List&lt;User&gt; userList = mapper.getUserList();        for (User suser : userList) &#123;            System.out.println(suser);        &#125;        //关闭sqlSession        sqlSession.close();    &#125;&#125;\n\n文件结构：\n\n\n\n\n常见问题：\n\nMaven导出资源问题java.io.IOException: Could not find resource mybatis-config.xml\n\n解决办法：pom.xml\n&lt;build&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/resources&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;true&lt;/filtering&gt;        &lt;/resource&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;true&lt;/filtering&gt;        &lt;/resource&gt;    &lt;/resources&gt;&lt;/build&gt;\n\n\n配置文件未注册\n接口绑定错误\n方法名错误\n返回类型错误\n\n3.3 CRUD需求1：根据用户id查询用户信息\n\n在Dao（Mapper层）添加相应接口方法\n\n//根据id查询用户public User getUserById(int id);\n\n\n在xml文件中实现查询语句并绑定接口方法（一个方法对应一个sql标签语句）\n\n&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.pans.pojo.User&quot;&gt;    select * from mybatis.user where id=1;&lt;/select&gt;\n\n\n测试\n\n @Testpublic void testGetUserById()&#123;    SqlSession sqlSession = MybatisUtils.getSqlSession();    UserDao mapper = sqlSession.getMapper(UserDao.class);    User user = mapper.getUserById(1);    System.out.println(user);        sqlSession.close();&#125;\n\n 需求2：增加&#x2F;修改&#x2F;删除 用户\nDao接口：\n//增加用户public void addUser(User user);//修改用户public void upDateUser(User user);//删除一个用户public  void deleteUser(int id);\n\n接口对应xml\n&lt;!--    增加用户,实体类的属性可以直接用--&gt;    &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.pans.pojo.User&quot;&gt;        insert into mybatis.user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);    &lt;/insert&gt;&lt;!--    修改用户--&gt;    &lt;update id=&quot;upDateUser&quot; parameterType=&quot;com.pans.pojo.User&quot;&gt;        update mybatis.user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id=#&#123;id&#125;;    &lt;/update&gt;&lt;!--   删除用户--&gt;    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;        delete from mybatis.user where id=#&#123;id&#125;;    &lt;/delete&gt;\n\n&#x3D;&#x3D;注意：&#x3D;&#x3D;\n\n当接口参数个数大于1时该如何处理？\n注意在增删改时最后必须提交事务\n\n测试类：\n @Testpublic  void testAddUser()&#123;     SqlSession sqlSession = MybatisUtils.getSqlSession();     UserDao mapper = sqlSession.getMapper(UserDao.class);     mapper.addUser(new User(5,&quot;apa&quot;,&quot;3412&quot;));     sqlSession.commit();    //提交事务     sqlSession.close(); &#125; @Testpublic void testUpdateUser()&#123;    SqlSession sqlSession=MybatisUtils.getSqlSession();     UserDao mapper = sqlSession.getMapper(UserDao.class);     mapper.upDateUser(new User(4,&quot;hello&quot;,&quot;world&quot;));     sqlSession.commit();\t\t  //提交事务     sqlSession.close(); &#125; @Testpublic void testDeleteUser()&#123;    SqlSession sqlSession=MybatisUtils.getSqlSession();     UserDao mapper = sqlSession.getMapper(UserDao.class);     mapper.deleteUser(5);     sqlSession.commit();\t\t  //提交事务    sqlSession.commit(); &#125;\n\n3.4 Map（多参数）Dao接口：\n//增加用户（多参数）public void addUser2(Map map);\n\nxml：\n&lt;!--    增加用户2（多参数）--&gt;    &lt;insert id=&quot;addUser2&quot; parameterType=&quot;map&quot; &gt;        insert into user (id,name,pwd) values(#&#123;userId&#125;,#&#123;userName&#125;,#&#123;userPwd&#125;);    &lt;/insert&gt;\n\nTest.java\n@Testpublic void testAddUser2()&#123;   SqlSession sqlSession = MybatisUtils.getSqlSession();    UserDao mapper = sqlSession.getMapper(UserDao.class);    HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();    map.put(&quot;userId&quot;,6);     map.put(&quot;userName&quot;,&quot;asdasd&quot;);    map.put(&quot;userPwd&quot;,&quot;dasdas&quot;);    mapper.addUser2(map);    sqlSession.commit();   sqlSession.commit();&#125;\n\n3.5 模糊查询Dao接口：\n//模糊查询public List&lt;User&gt; getUserLike(String subName);\n\nmapper.xml——&gt;1\n&lt;select id=&quot;getUserLike&quot; parameterType=&quot;String&quot; resultType=&quot;com.pans.pojo.User&quot;&gt;    select * from user where name like %#&#123;value&#125;%&lt;/select&gt;\n\nmapper.xml——-&gt;2\n&lt;select id=&quot;getUserLike&quot; parameterType=&quot;String&quot; resultType=&quot;com.pans.pojo.User&quot;&gt;    select * from user where name like #&#123;value&#125;&lt;/select&gt;\n\nTest—–&gt;1\n @Testpublic void testGetUserLike()&#123;    SqlSession sqlSession = MybatisUtils.getSqlSession();     UserDao mapper = sqlSession.getMapper(UserDao.class);     List&lt;User&gt; user = mapper.getUserLike(&quot;张&quot;);     for (User user1 : user) &#123;         System.out.println(user1);     &#125;     sqlSession.close(); &#125;\n\nTest—&gt;2\n @Testpublic void testGetUserLike()&#123;    SqlSession sqlSession = MybatisUtils.getSqlSession();     UserDao mapper = sqlSession.getMapper(UserDao.class);     List&lt;User&gt; user = mapper.getUserLike(&quot;张%&quot;);     for (User user1 : user) &#123;         System.out.println(user1);     &#125;     sqlSession.close(); &#125;\n\n思考：\n方式1是在sql里面写通配符\n方式2是在查询语句中写通配符\n此时两种方式是否存在sql注入问题！\n3、配置解析3.1 属性优化mybatis-config.xml里面的properties属性可以引入外部配置文件db.properties\ndriver=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghaiusername=rootpassword=123456\n\nmybatis-config.xml中的标签必须按照规定顺序：\n&lt;configuration&gt;&lt;!--    引入外部配置文件,也可增加自定义属性值--&gt;    &lt;properties resource=&quot;db.properties&quot;&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;    &lt;/properties&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;com/pans/dao/UserMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\n3.3 别名优化(不区分大小写)&#x3D;&#x3D;Java编译后的字节码文件名不区分大小写，即同一个包下不能有两个仅有大小写区分的类名&#x3D;&#x3D;\n\n在mybatis-config.xml可以使用typeAliases便签进行实体类别名优化： 它仅用于 XML 配置，意在降低冗余的全限定类名书写\n\n&lt;typeAliases&gt;    &lt;typeAlias type=&quot;com.pans.pojo.User&quot; alias=&quot;User&quot;/&gt;&lt;/typeAliases&gt;\n\n对应的mapper.xml\n&lt;select id=&quot;getUserList&quot; resultType=&quot;User&quot;&gt;    select * from mybatis.user&lt;/select&gt;\n\n\n也可以指定一个包名，实体类的每一个类的别名为其首字母小写！（大写也可以）\n\n&lt;typeAliases&gt;    &lt;typeAlias type=&quot;com.pans.pojo&quot;/&gt;&lt;/typeAliases&gt;\n\n\n也可在实体类中加入注解Alias作为其别名\n\n@Alias(&quot;user&quot;)public class User &#123;  public User(long id, String name, String pwd) &#123;    this.id = id;    this.name = name;    this.pwd = pwd;  &#125;\n\n3.4 设置\n数据库不区分大小写，故用下划线区分！\n3.5 映射器（Mapper）方式一：\n&lt;mappers&gt;    &lt;mapper resource=&quot;com/pans/dao/UserMapper.xml&quot;/&gt;&lt;/mappers&gt;\n\n方式二：使用class文件注册\n    &lt;mappers&gt;&lt;!--        &lt;mapper resource=&quot;com/pans/dao/UserMapper.xml&quot;/&gt;--&gt;        &lt;mapper class=&quot;com.pans.dao.UserMapper&quot;/&gt;    &lt;/mappers&gt;\n\n注意：接口和其配置文件必须同名且在同一个包下！！！\n方式三：使用包名\n&lt;mappers&gt;    &lt;package name=&quot;com.pans.dao&quot;/&gt;&lt;/mappers&gt;\n\n3.6 生命周期和作用域用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题。\nSqlSessionFactoryBuilder：\n这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要（用于局部方法变量）；\nSqlSessionFactory：（数据库连接池）\nSqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例（用于应用作用域）；\n可以使用单例模式或静态单例模式。\nSqlSession：（数据库请求，用完需要关闭）\n每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的（请求或方法作用域）\n\n4、属性名和字段名不一致问题数据库中的字段和实体类中的字段名不一致的情况。\n&lt;!--    结果集映射--&gt;   &lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt;&lt;!--       column数据库中的字段，property实体类的属性--&gt;       &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;       &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;&lt;!--       实体字段名和表字段名不一致--&gt;       &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;   &lt;/resultMap&gt;&lt;!--    根据id查询用户--&gt;    &lt;select id=&quot;getUserList&quot; resultMap=&quot;UserMap&quot;&gt;        select id,name,pwd from mybatis.user where id=$&#123;id&#125;    &lt;/select&gt;\n\n5、日志\n标准日志工厂\n\n&lt;settings&gt;    &lt;setting name=&quot;logImpl&quot;   value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt;\n\n\nLog4j\n\n\nmaven依赖：\n\n&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;&lt;dependency&gt;    &lt;groupId&gt;log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j&lt;/artifactId&gt;    &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;\n\n\n增加配置文件log4j.properties\n\n### set log levels ###log4j.rootLogger = stdout,D### 输出到控制台 ###log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = %d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### 输出到日志文件 ###log4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File =./log/pans-info.loglog4j.appender.D.Append = truelog4j.appender.D.MaxFileSize = 10mblog4j.appender.D.Threshold = DEBUGlog4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n\n\n\n测试\n\n@Testpublic void testLog4j()&#123;    Logger logger = Logger.getLogger(UserDaoTest.class);    logger.info(&quot;进入Log4j=====&gt;info方法！&quot;);    logger.debug(&quot;进入Log4j=====&gt;debug方法！&quot;);    logger.error(&quot;进入Log4j=====&gt;error方法！&quot;);&#125;\n\n6、分页\nmysql里的分页limit\n\nselect * from user limit startIndex,pageSize;\n\n\nMybatis分页：\n\n除了修改sql语句，还需使用map\n&lt;!--    查询用户，分页--&gt;    &lt;select id=&quot;getUserByPage&quot; parameterType=&quot;map&quot; resultMap=&quot;userList&quot;&gt;        select * from user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;;    &lt;/select&gt;\n\nMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();map.put(&quot;startIndex&quot;,2);map.put(&quot;pageSize&quot;,2);\n\n\npageHelper插件！！\n\n7、使用注解开发直接在接口上方使用注解写sql语句，并在xml配置文件mapper属性改为class接口。(自动提交事务)\n@Select(&quot;select * from user&quot;)public User getUserList();\n\n//根据id查询用户@Select(&quot;select * from user where id=$&#123;id&#125;&quot;)public User getUserById(@Param(&quot;id&quot;)int id);\n\n关于@param：\n\n基本类型为参数或者String类型，需要加上\n引用类型可以不用加\n\n8、Lombok直接在实体类前加@Data可以自动生成get&#x2F;set&#x2F;constructer等方法。。。\n9、多对一处理\n子查询\n\n联表查询\n\n\nSELECT u.`id`,u.`name`,t.`name` FROM `user` AS u,`teacher`AS tWHERE u.`teacher_id`=t.`id`;\n\nStudentMapper.xml\n&lt;!--接口实现--&gt;&lt;mapper namespace=&quot;com.pans.dao.StudentMapper&quot;&gt;&lt;!--    联表查询用户及其对应老师信息--&gt;    &lt;select id=&quot;getStudentList&quot; resultMap=&quot;studentList&quot;&gt;        SELECT s.`id` id,s.`name` sname,t.`name` tname        FROM teacher t,student s        WHERE s.tid=t.id;    &lt;/select&gt;    &lt;resultMap id=&quot;studentList&quot; type=&quot;student&quot;&gt;        &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt;        &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;        &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt;            &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;        &lt;/association&gt;    &lt;/resultMap&gt;&lt;/mapper&gt;\n\n注意：实体类属性与数据库列并不是一一对应：（即属性名与字段不一致）\npublic class Student &#123;  private long id;  private String name;\t//数据库中的属性为tI作为Student表的外键  //学生需要关联的老师  private Teacher teacher;&#125;\n\n10、一对多处理(略)11、动态SQL何为动态sql：\n&#x3D;&#x3D;动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式进行组合，而无需在业务层面就行查询。&#x3D;&#x3D;\n\n导包\n\n&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.18.20&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;\n\n\n编写配置文件（注意开启驼峰命名自动转换）\n\n&lt;mappers&gt;    &lt;mapper resource=&quot;com/pans/dao/BlogMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;settings&gt;    &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;\n\n\n编写实体类及其Mapper接口及其实现的xml文件\n\n@AllArgsConstructor@NoArgsConstructorpublic class Blog &#123;  private String id;  private String title;  private String author;  private Date createTime;  //属性名和字段名不一致,需开启驼峰命名转换  private long views;\n\npublic interface BlogMapper &#123;    //插入数据    public void addBlog(Blog blog);&#125;\n\n&lt;mapper namespace=&quot;com.pans.dao.BlogMapper&quot;&gt;    &lt;insert id=&quot;addBlog&quot; parameterType=&quot;blog&quot;&gt;        insert into blog(id,title,author,create_time,views)        values(#&#123;id&#125;,#&#123;title&#125;,#&#123;author&#125;,#&#123;createTime&#125;,#&#123;views&#125;);    &lt;/insert&gt;&lt;/mapper&gt;\n\n\n编写测试文件\n\nimport com.pans.dao.BlogMapper;import com.pans.pojo.Blog;import com.pans.utils.IDutils;import com.pans.utils.MybatisUtils;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.Date;public class Mytest &#123;    @Test    public void addBlogTest() &#123;        SqlSession sqlSession = MybatisUtils.getSqlSession();        BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);        Blog blog = new Blog();        blog.setId(IDutils.getID());        blog.setTitle(&quot;Mybatis&quot;);        blog.setAuthor(&quot;狂神说&quot;);        blog.setCreateTime(new Date());        blog.setViews(9999);        mapper.addBlog(blog);        blog.setId(IDutils.getID());        blog.setTitle(&quot;Java&quot;);        mapper.addBlog(blog);        blog.setId(IDutils.getID());        blog.setTitle(&quot;Spring&quot;);        mapper.addBlog(blog);        blog.setId(IDutils.getID());        blog.setTitle(&quot;微服务&quot;);        mapper.addBlog(blog);        sqlSession.commit();        sqlSession.close();    &#125;&#125;\n\n1、 if语句\nmapper接口\n\n//动态SQL之IF语句public List&lt;Blog&gt; queryByIf(Map map);\n\n\nmapper配置文件\n\n&lt;!--    动态Sql之IF语句--&gt;    &lt;select id=&quot;queryByIf&quot; parameterType=&quot;map&quot; resultType=&quot;Blog&quot;&gt;        select * from blog where 1=1    &lt;if test=&quot;title != null&quot;&gt;        and title=#&#123;title&#125;;    &lt;/if&gt;    &lt;if test=&quot;author!=null&quot;&gt;        and author=&quot;狂神说&quot;;    &lt;/if&gt;    &lt;/select&gt;\n\n\n测试文件\n\n@Testpublic void testQueryByIf()&#123;    SqlSession sqlSession = MybatisUtils.getSqlSession();    BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);    Map map = new HashMap();    // map.put(&quot;title&quot;,&quot;Java&quot;);    map.put(&quot;author&quot;,&quot;dasd&quot;);    List&lt;Blog&gt; blogs = mapper.queryByIf(map);    for (Blog blog : blogs) &#123;        System.out.println(blog);    &#125;    sqlSession.close();&#125;\n\n2、where语句类似Java中的switch语句，并且where便签能自动识别第一个成立条件并去掉可能存在的and&#x2F;or。\n&lt;select id=&quot;queryByWhere&quot; resultType=&quot;blog&quot; parameterType=&quot;map&quot;&gt;    select * from blog    &lt;where&gt;        &lt;choose&gt;        &lt;when test=&quot;titile!=null&quot;&gt;            title=#&#123;title&#125;        &lt;/when&gt;                    &lt;when test=&quot;author!=null&quot;&gt;            author=#&#123;author&#125;        &lt;/when&gt;            &lt;otherwise&gt;            views=#&#123;views&#125;        &lt;/otherwise&gt;        &lt;/choose&gt;    &lt;/where&gt;&lt;/select&gt;\n\n3、set语句set元素会动态前置SET关键字，同时也会删掉无关的逗号\n4、foreach集合遍历\n12、缓存1、一级缓存一级缓存（本地会话缓存）默认开启，只在一次sqlSession中有效！\n查询相同数据的时候直接从缓存中获取，而无需经过数据库查询，提高系统效率。\n\n映射语句文件中的所有 select 语句的结果将会被缓存。\n映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。\n会使用（LRU,FIFO）等算法来刷新缓存。\n\n2、二级缓存开启方式：加标签&lt;cache/&gt;,又称全局缓存，可跨sqlSession缓存！\n3、自定义缓存","categories":["Mybatis"],"tags":["java","Mybatis","Mysql"]},{"title":"SMBMS","url":"/2022/04/26/java_SMBMS/","content":"\n\n超市订单管理系统1、整体架构\n2、项目搭建准备\n按webapp步骤搭建web项目（目录结构）—-&gt;\n\n配置Tomcat—–&gt;\n\n导入项目依赖jar（基本依赖）—-&gt;\n\n\n&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt;    &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt;    &lt;version&gt;5.0.0&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;jakarta.servlet.jsp&lt;/groupId&gt;    &lt;artifactId&gt;jakarta.servlet.jsp-api&lt;/artifactId&gt;    &lt;version&gt;3.0.0&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;8.0.21&lt;/version&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;\n\n\n创建项目包结构\n\n\n编写实体类\n\n\n​\t\tORM（表&lt;—-&gt;类）映射，可以在IDEA中根据数据库表自动生成（需要少量修改）。\n\n编写基础公共类\n\n\n数据库配置文件\n\ndriver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/smbms?useUnicode=true&amp;characterEncoding=utf-8user=rootpassword=123456\n\n\n编写数据库公共类\n\npackage com.pans.dao;import java.io.IOException;import java.io.InputStream;import java.sql.*;import java.util.Properties;//操作数据库的基类public class BaseDao &#123;    private static String driver;    private static String url;    private static String username;    private static String password;    //静态代码块，类加载时初始化    static &#123;        Properties properties = new Properties();        //通过类加载器读取资源        InputStream is = BaseDao.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;);        try &#123;            properties.load(is);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        driver = properties.getProperty(&quot;driver&quot;);        url = properties.getProperty(&quot;url&quot;);        username = properties.getProperty(&quot;username&quot;);        password = properties.getProperty(&quot;password&quot;);    &#125;    //获取数据库链接    public static Connection getConnection() throws ClassNotFoundException, SQLException &#123;        //Connection connection=null;        Class.forName(driver);        Connection connection = DriverManager.getConnection(url, username, password);        return connection;    &#125;    //编写查询公共类    public static ResultSet excute(Connection connection,String sql,Object[] params,ResultSet resultSet, PreparedStatement preparedStatement) throws SQLException &#123;        preparedStatement = connection.prepareStatement(sql);        for (int i = 0; i &lt; params.length; i++) &#123;            preparedStatement.setObject(i+1,params[i]);        &#125;        resultSet = preparedStatement.executeQuery();        return resultSet;    &#125;    //编写增删改公共方法    public static int excute(Connection connection,String sql,Object[] params, PreparedStatement preparedStatement) throws SQLException &#123;        preparedStatement = connection.prepareStatement(sql);        for (int i = 0; i &lt; params.length; i++) &#123;            preparedStatement.setObject(i+1,params[i]);        &#125;        int updateRows= preparedStatement.executeUpdate();        return updateRows;    &#125;    //关闭链接，释放资源    public static boolean closeResource(Connection connection,PreparedStatement preparedStatement,ResultSet resultSet) &#123;        boolean flag = true;        if(resultSet != null)&#123;            try &#123;                resultSet.close();                //GC回收                resultSet = null;            &#125;catch (Exception e)&#123;                flag = false;            &#125;        &#125;        if(preparedStatement != null)&#123;            try &#123;                preparedStatement.close();                //GC回收                preparedStatement = null;            &#125;catch (Exception e)&#123;                flag = false;            &#125;        &#125;        if(connection != null)&#123;            try &#123;                connection.close();                //GC回收                connection = null;            &#125;catch (Exception e)&#123;                flag = false;            &#125;        &#125;        return flag;    &#125;&#125;\n\n\n编写字符编码过滤器并在web.xml中注册\n\npackage com.pans.filter;import javax.servlet.*;import java.io.IOException;public class CharacterEncodingFilter implements Filter &#123;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;        Filter.super.init(filterConfig);    &#125;    @Override    public void destroy() &#123;        Filter.super.destroy();    &#125;    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        request.setCharacterEncoding(&quot;utf-8&quot;);        response.setCharacterEncoding(&quot;utf-8&quot;);        chain.doFilter(request,response);    &#125;&#125;\n\n\n导入静态资源\n\n3、登录功能实现\n1. 编写前端页面login.jsp2. 设置首页为login.jsp&lt;welcome-file-list&gt;    &lt;welcome-file&gt;login.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt;\n\n3. 编写Dao层登录用户登陆的接口package com.pans.dao.user;import com.pans.pojo.User;import java.sql.Connection;public interface UserDao &#123;    //得到登录的用户信息    public User getLoginUser(Connection connection, String userCode) throws Exception;&#125;\n\n4. 编写Dao接口的实现类package com.pans.dao.user;import com.pans.dao.BaseDao;import com.pans.pojo.User;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;public class UserDaoImpl implements UserDao&#123;    @Override    public User getLoginUser(Connection connection, String userCode) throws Exception &#123;        PreparedStatement pstm = null;        ResultSet rs = null;        User user = null;        if(null != connection)&#123;            String sql = &quot;select * from smbms_user where userCode=?&quot;;            Object[] params = &#123;userCode&#125;;            rs = BaseDao.execute(connection, pstm, rs, sql, params);            if(rs.next())&#123;                user = new User();                user.setId(rs.getInt(&quot;id&quot;));                user.setUserCode(rs.getString(&quot;userCode&quot;));                user.setUserName(rs.getString(&quot;userName&quot;));                user.setUserPassword(rs.getString(&quot;userPassword&quot;));                user.setGender(rs.getInt(&quot;gender&quot;));                user.setBirthday(rs.getDate(&quot;birthday&quot;));                user.setPhone(rs.getString(&quot;phone&quot;));                user.setAddress(rs.getString(&quot;address&quot;));                user.setUserRole(rs.getInt(&quot;userRole&quot;));                user.setCreatedBy(rs.getInt(&quot;createdBy&quot;));                user.setCreationDate(rs.getTimestamp(&quot;creationDate&quot;));                user.setModifyBy(rs.getInt(&quot;modifyBy&quot;));                user.setModifyDate(rs.getTimestamp(&quot;modifyDate&quot;));            &#125;            BaseDao.closeResource(null, pstm, rs);        &#125;        return user;    &#125;&#125;\n\n5. 编写业务层接口及其实现类&#x3D;&#x3D;此时在做测试的遇到的bug：&#x3D;&#x3D;\npackage com.pans.service.user;import com.pans.dao.BaseDao;import com.pans.dao.user.UserDao;import com.pans.dao.user.UserDaoImpl;import com.pans.pojo.User;import org.junit.Test;import java.sql.Connection;import java.sql.SQLException;public class UserServiceImpl implements UserService&#123;    //业务层都会调用dao层，所以需要引入dao层    private UserDao userDao;    public UserServiceImpl() &#123;       userDao = new UserDaoImpl();    &#125;    @Override    public User login(String userCode, String password) &#123;        Connection connection = null;        User user = new User();        try &#123;            connection = BaseDao.getConnection();            //通过业务层调用对应的具体数据库操作           user = userDao.getLoginUser(connection, userCode);        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;finally &#123;            BaseDao.closeResource(connection,null,null);        &#125;        return user;    &#125;&#125;\n\n&#x3D;&#x3D;bug1：&#x3D;&#x3D;\njava.sql.SQLException: Access denied for user &#x27;&#x27;@&#x27;localhost&#x27; (using password: YES)\n\n错误原因：\nBaseDao里面\nusername = properties.getProperty(&quot;username&quot;);\n\n对应的db.properties\nuser=rootpassword=123456\n\n注意配置文件里的名字要和BaseDao一致！！！\n&#x3D;&#x3D;bug2：&#x3D;&#x3D;\njava.sql.SQLException: The server time zone value &#x27;�й���׼ʱ��&#x27; is unrecognized or represents more than one time\n\n错误原因：\n需要在配置文件的url里面加上时区！！！\nurl=jdbc:mysql://localhost:3306/smbms?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai\n\n6. 业务层接口package com.pans.service.user;import com.pans.pojo.User;import java.sql.SQLException;public interface UserService &#123;    //用户登录    public User login(String userCode,String password) throws Exception;&#125;\n\n7. 业务层实现package com.pans.service.user;import com.pans.dao.BaseDao;import com.pans.dao.user.UserDao;import com.pans.dao.user.UserDaoImpl;import com.pans.pojo.User;import org.junit.Test;import java.sql.Connection;import java.sql.SQLException;public class UserServiceImpl implements UserService&#123;    //业务层都会调用dao层，所以需要引入dao层    private UserDao userDao;    public UserServiceImpl() &#123;       userDao = new UserDaoImpl();    &#125;    @Override    public User login(String userCode, String password) &#123;        Connection connection = null;        User user = new User();        try &#123;            connection = BaseDao.getConnection();            //通过业务层调用对应的具体数据库操作           user = userDao.getLoginUser(connection, userCode);        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;finally &#123;            BaseDao.closeResource(connection,null,null);        &#125;        return user;    &#125;    @Test    public void test()&#123;        UserServiceImpl userService = new UserServiceImpl();        User admin = userService.login(&quot;wen&quot;, &quot;123&quot;);        System.out.println(admin.getUserPassword());    &#125;&#125;\n\n8. 编写Servlet处理请求package com.pans.servlet.user;import com.pans.pojo.User;import com.pans.service.user.UserServiceImpl;import com.pans.util.Constants;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class LoginServlet extends HttpServlet &#123;    //控制层调用业务层代码    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doPost(req, resp);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot;ServletLogin===========start!!&quot;);        //获取用户名和密码        String userCode = req.getParameter(&quot;userCode&quot;);        String password = req.getParameter(&quot;userPassword&quot;);        //和数据库密码进行对比，调用业务层        UserServiceImpl userService = new UserServiceImpl();        User user = userService.login(userCode, password);   //查此人返回信息        if(user!=null)&#123; //查有此人，继续验证密码是否正确            if(user.getUserPassword().equals(password))&#123;                //将用户信息放到Session中                req.getSession().setAttribute(Constants.USER_SESSION,user);                //跳转到首页                resp.sendRedirect(&quot;jsp/frame.jsp&quot;);            &#125;else&#123;                //密码错误，无法登录                //转发登录界面，顺带提示，密码错误                req.setAttribute(&quot;error&quot;,&quot;密码错误！&quot;);                req.getRequestDispatcher(&quot;login.jsp&quot;).forward(req,resp);            &#125;        &#125;else&#123;//查无此人，无法登录            //转发登录界面，顺带提示，用户名或者密码错误            req.setAttribute(&quot;error&quot;,&quot;用户名不存在&quot;);            req.getRequestDispatcher(&quot;login.jsp&quot;).forward(req,resp);        &#125;    &#125;&#125;\n\n9. 添加servlet依赖&lt;servlet&gt;    &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.pans.servlet.user.LoginServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/login.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\n\n4、登录功能优化1、注销功能\n编写Servlet并注册\n\npackage com.pans.servlet.user;import com.pans.util.Constants;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class LoginoutServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doPost(req, resp);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //移除用户Seession        req.getSession().removeAttribute(Constants.USER_SESSION);        resp.sendRedirect(req.getContextPath()+&quot;/login.jsp &quot;);    &#125;&#125;\n\n&lt;!--注销页面--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;LoginoutServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;com.pans.servlet.user.LoginoutServlet&lt;/servlet-class&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;LoginoutServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/jsp/logout.do&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;\n\n2、登录拦截\n编写Servlet过滤器+注册过滤器\n\npackage com.pans.filter;import com.pans.pojo.User;import com.pans.util.Constants;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class SysFilter implements Filter &#123;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;        Filter.super.init(filterConfig);    &#125;    @Override    public void destroy() &#123;        Filter.super.destroy();    &#125;    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        //由于servletRequest无法获取Session,转化为        HttpServletRequest request1 = (HttpServletRequest) request;        HttpServletResponse response1 = (HttpServletResponse) response;        //过滤器，从Session中获取用户信息        User user = (User) request1.getSession().getAttribute(Constants.USER_SESSION);        if(user==null)&#123;  //已经被移除或者注销未登录            response1.sendRedirect(&quot;/smbms/error.jsp&quot;);        &#125;else&#123;            chain.doFilter(request,response);        &#125;    &#125;&#125;\n\n&lt;!--用户登录过滤器--&gt;    &lt;filter&gt;        &lt;filter-name&gt;SysFilter&lt;/filter-name&gt;        &lt;filter-class&gt;com.pans.filter.SysFilter&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;SysFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/jsp/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;\n\n&#x3D;&#x3D;此时遇到一个bug：&#x3D;&#x3D;\nclass org.apache.catalina.connector.RequestFacade cannot be cast to class javax.servlet.http.HttpServletResponse (org.apache.catalina.connector.RequestFacade and javax.servlet.http.HttpServletResponse are in unnamed module of loader java.net.URLClassLoader @33723e30)\n\n经过检查发现在过滤器中&#x3D;&#x3D;类型转换错误：&#x3D;&#x3D;\nHttpServletResponse response1 = (HttpServletResponse) response;\n\n写成了：&#x3D;&#x3D;（由于使用了快速提示没有注意到名字！）&#x3D;&#x3D;\nHttpServletResponse response1 = (HttpServletResponse) resquest;\n\n3、修改密码\n导入&#x2F;编写前端js界面\n理清思路架构\n\n\n\nUserDao接口\n\n//修改当前用户密码public  int updatePwd(Connection connection,String userCode,String password) throws SQLException;\n\n\nUserDao实现类\n\n//修改用户密码@Overridepublic int updatePwd(Connection connection,String userCode, String  password) throws SQLException &#123;    int rows=0;    if(connection!=null)&#123;        String sql=&quot;update smbms_user set userPassword=? where userCode=?&quot;;        PreparedStatement preparedStatement=null;        Object[] params = &#123;password,userCode&#125;;        rows = BaseDao.execute(connection,preparedStatement,sql,params);        BaseDao.closeResource(connection,preparedStatement,null);    &#125;    return rows;&#125;\n\n\nService接口\n\n//修改用户密码public boolean updatePwd(String userCode,String password);\n\n\nService实现类\n\n//根据用户ID修改用户密码@Overridepublic boolean updatePwd(String userCode, String password) &#123;    boolean flag=false;    Connection connection = null;    try &#123;        connection = BaseDao.getConnection();        if(userDao.updatePwd(connection,userCode,password)&gt;0)&#123;            flag=true;        &#125;    &#125; catch (SQLException | ClassNotFoundException e) &#123;        e.printStackTrace();    &#125; finally &#123;        BaseDao.closeResource(connection,null,null);    &#125;    return flag;&#125;\n\n\nServlet实现\n\npackage com.pans.servlet.user;import com.pans.pojo.User;import com.pans.service.user.UserServiceImpl;import com.pans.util.Constants;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class updatePwd extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //获取用户userCode        Object attribute = req.getSession().getAttribute(Constants.USER_SESSION);        String newpassword = req.getParameter(&quot;newpassword&quot;);//        System.out.println(attribute);////        System.out.println(&quot;进入updatePwd-Servlet=====&quot;+newpassword);        boolean flag=false;        if(attribute!=null&amp;&amp;newpassword!=null&amp;&amp;newpassword.length()!=0)&#123;            UserServiceImpl userService = new UserServiceImpl();            flag=userService.updatePwd(((User)attribute).getUserCode(),newpassword);            //System.out.println(&quot;业务层返回结果为：&quot;+flag);            if(flag)&#123;                req.setAttribute(&quot;message&quot;,&quot;密码修改成功，请返回重新登录！&quot;);                //移除当前Session                req.getSession().removeAttribute(Constants.USER_SESSION);                //跳转到登录页                //System.out.println(&quot;准备重新跳转到登录页！&quot;);               resp.sendRedirect(&quot;/smbms/login.jsp&quot;);            &#125;        &#125;else&#123;            req.setAttribute(&quot;message&quot;,&quot;密码修改失败！&quot;);            req.getRequestDispatcher(&quot;pwdmodify.jsp&quot;).forward(req,resp);        &#125;       // req.getRequestDispatcher(&quot;pwdmodify.jsp&quot;).forward(req,resp);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doGet(req, resp);    &#125;&#125;\n\n4、Ajax验证旧密码\n导入相关依赖\n\n  阿里巴巴工具转换（map--&gt;json）&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.75&lt;/version&gt;  &lt;/dependency&gt;\n\n\n旧密码验证只需要在前端验证（旧密码从Session中获得）\n\n    //前端验证用户旧密码    public void pwdModify(HttpServletRequest req, HttpServletResponse resp)&#123;        //获取前端用户密码        String oldPassword = req.getParameter(&quot;oldpassword&quot;);        //System.out.println(oldPassword);        //获取session里面的密码        Object attribute = req.getSession().getAttribute(Constants.USER_SESSION);        String userRealPassword = ((User) attribute).getUserPassword();       // System.out.println(userRealPassword);        Map&lt;String, String&gt; resultMap = new HashMap&lt;String,String&gt;();        if(attribute==null)&#123;  //Session失效            resultMap.put(&quot;result&quot;,&quot;sessionerror&quot;);        &#125;else if(StringUtils.isNullOrEmpty(oldPassword))&#123;  //密码为空            resultMap.put(&quot;result&quot;,&quot;error&quot;);        &#125;else&#123;            if(oldPassword.equals(userRealPassword))&#123;//密码正确                resultMap.put(&quot;result&quot;,&quot;true&quot;);            &#125;else&#123;                resultMap.put(&quot;result&quot;,&quot;false&quot;);            &#125;        &#125;        //以json格式响应到客户端        resp.setContentType(&quot;application/json&quot;);        try &#123;            PrintWriter writer = resp.getWriter();            //JSONArray 阿里巴巴的JSON工具类：转换格式： MAP----&gt;JSON            writer.write(JSONArray.toJSONString(resultMap));            writer.flush();            writer.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; &#125;前端响应结果为：&#123;&quot;result&quot;:&quot;true/false/...&quot;&#125;\n\n\n复用servlet（&#x3D;&#x3D;因为在前端中的action路径都是该servlet的路径&#x3D;&#x3D;）\n\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    //先获取前端参数以确定服务类型    String method = req.getParameter(&quot;method&quot;);    if(method.equals(&quot;pwdmodify&quot;))&#123; //验证旧密码        this.pwdModify(req,resp);    &#125;else if(method.equals(&quot;savepwd&quot;))&#123;//修改密码         this.updatePassword(req,resp);    &#125;&#125;\n\n&#x3D;&#x3D;注意js文件渲染后的乱码问题：&#x3D;&#x3D;将js文件用文本打开，然后另存为的时候选择utf-8 BOOM编码格式即可！！！\n","categories":["java items"],"tags":["java","items"]},{"title":"java中的volatile关键字","url":"/2022/04/12/java_volatile/","content":"\n\nJava volatile关键字分析目录\n一、简介\n二、并发编程3大基本概念\n三、锁的互斥性和可见性\n四、Java的内存模型 JMM 以及共享变量的可见性\n五、volatile变量的特性\n六、volatile适用的场景\n七、volatile原理\n\n一、简介​\t\tvolatile 是Java提供的一种轻量级的同步机制。Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量，相比于synchronized（synchronized通常称为重量级锁），volatile更轻量级，因为它不会引起线程上下文的切换和调度。但是volatile 变量的同步性较差（有时它更简单并且开销更低），而且其使用也更容易出错。\n​\t\t计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。\n　　也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：\ni = i + 1；\n\n当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。\n　　这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。\n　　比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？\n　　可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。\n　　最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。\n　　也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。\n　　为了解决缓存不一致性问题，通常来说有以下2种解决方法：\n　　1）通过在总线加LOCK#锁的方式\n　　2）通过缓存一致性协议\n　　这2种方式都是硬件层面上提供的方式。\n　　在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i &#x3D; i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。\n　　但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。\n　　所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。\n\n二、并发编程3大基本概念原子性，可见性，有序性\n1.原子性\n原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。\n　　一个很经典的例子就是银行账户转账问题：\n　　比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。\n　　试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。\n　　所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。\n　　同样地反映到并发编程中会出现什么结果呢？\n　　举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？\ni = 9;\n\n 　假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。\n　　那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。\n2.可见性\n　　可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。\n　　举个简单的例子，看下面这段代码：\n//线程1执行的代码int i = 0;i = 10;//线程2执行的代码j = i;\n\n 　假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i &#x3D;10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。\n　　此时线程2执行 j &#x3D; i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.\n　　这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。\n3.有序性\n　　有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：\nint i =  0;       boolean flag = false ;i = 1;         //语句1 flag = true;   //语句2\n\n 　上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。\n　　下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。\n　　比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。\n　　但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：\nint a = 10;  //语句1int r = 2;  //语句2a = a + 3;  //语句3r = a*a;   //语句4\n\n 　这段代码有4个语句，那么可能的一个执行顺序是：　\n　　那么可不可能是这个执行顺序呢： 语句2  语句1  语句4  语句3\n　　不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。\n　　虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：\n//线程1:context = loadContext();  //语句1inited = true;       //语句2//线程2:while(!inited )&#123; \tsleep()&#125;doSomethingwithconfig(context);\n\n 　上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。\n 　从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。\n　　也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。\n三、锁的互斥性和可见性锁提供了两种主要特性：互斥（mutual exclusion） 和可见性（visibility）。\n（1）互斥即一次只允许一个线程持有某个特定的锁，一次就只有一个线程能够使用该共享数据。\n（2）可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的。也即当一条线程修改了共享变量的值，新值对于其他线程来说是可以立即得知的。如果没有同步机制提供的这种可见性保证，线程看到的共享变  量可能是修改前的值或不一致的值，这将引发许多严重问题。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：\n​\ta.对变量的写操作不依赖于当前值。\n​\tb.该变量没有包含在具有其他变量的不变式中。\n​\t\t实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。事实上就是保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。\n四、Java的内存模型 JMM 以及共享变量的可见性​\t\t JMM决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory），本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。\n\n​\t\t对于普通的共享变量来讲，线程A将其修改为某个值发生在线程A的本地内存中，此时还未同步到主内存中去；而线程B已经缓存了该变量的旧值，所以就导致了共享变量值的不一致。解决这种共享变量在多线程模型中的不可见性问题，较粗暴的方式自然就是加锁，但是此处使用synchronized或者Lock这些方式太重量级了，比较合理的方式其实就是volatile。\n五、volatile变量的特性1.保证可见性，不保证原子性  （1）当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去；\n  （2）这个写会操作会导致其他线程中的volatile变量缓存无效。\n 2.禁止指令重排    重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。重排序需要遵守一定规则：\n （1）重排序操作不会对存在数据依赖关系的操作进行重排序。\n　 比如：a&#x3D;1;b&#x3D;a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。\n （2）重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变\n　 比如：a&#x3D;1;b&#x3D;2;c&#x3D;a+b这三个操作，第一步（a&#x3D;1)和第二步(b&#x3D;2)由于不存在数据依赖关系， 所以可能会发生重排序，但是c&#x3D;a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c&#x3D;a+b&#x3D;3。\n​\t\t重排序在单线程下一定能保证结果的正确性，但是在多线程环境下，可能发生重排序，影响结果，下例中的1和2由于不存在数据依赖关系，则有可能会被重排序，先执行status&#x3D;true再执行a&#x3D;2。而此时线程B会顺利到达4处，而线程A中a&#x3D;2这个操作还未被执行，所以b&#x3D;a+1的结果也有可能依然等于2。\npublic class TestVolatile&#123;int a = 1;boolean status = false;//状态切换为truepublic void changeStatus&#123;a = 2;   //1status = true;  //2&#125;//若状态为true，则为runningpublic void run()&#123;\tif(status)&#123;   //3\tint b = a + 1;  //4\tSystem.out.println(b);\t\t&#125;\t&#125;&#125;\n\n     使用volatile关键字修饰共享变量便可以禁止这种重排序。若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序,volatile禁止指令重排序也有一些规则：\n\n​\t\ta.当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；​\t\tb.在进行指令优化时，不能将对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。​\t\t即执行到volatile变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对volatile变量及其后面语句可见。\n3.volatile的原理和实现机制\n　　前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。\n　　下面这段话摘自《深入理解Java虚拟机》：\n　　“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”\n　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：\n　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；\n　　2）它会强制将对缓存的修改操作立即写入主存；\n　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。\n六、volatile适用的场景​\t\tsynchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：\n　　1）对变量的写操作不依赖于当前值\n　　2）该变量没有包含在具有其他变量的不变式中\n　　实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。\n　　事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。\n　　下面列举几个Java中使用volatile的几个场景。\n1.状态标记量\nvolatile boolean flag = false; while(!flag)&#123;    doSomething();&#125; public void setFlag() &#123;    flag = true;&#125;\n\n\n\nvolatile boolean inited = false;//线程1:context = loadContext();  inited = true;             //线程2:while(!inited )&#123;sleep()&#125;doSomethingwithconfig(context);\n\n2.double check\nclass Singleton&#123;    private volatile static Singleton instance = null;         private Singleton() &#123;             &#125;         public static Singleton getInstance() &#123;        if(instance==null) &#123;            synchronized (Singleton.class) &#123;                if(instance==null)                    instance = new Singleton();            &#125;        &#125;        return instance;    &#125;&#125;\n\n七、volatile原理​\t\tvolatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：\n（1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；\n（2）它会强制将对缓存的修改操作立即写入主存；\n（3）如果是写操作，它会导致其他CPU中对应的缓存行无效。\n\n","categories":["java"],"tags":["Java","并发编程JUC","volatile"]},{"title":"java并发编程JUC","url":"/2022/04/13/java_juc/","content":"\n\n1、什么是JUC\n回顾：Runnable接口与Callable接口：\n\ncallable的核心是call方法，允许返回值，runnable的核心是run方法，没有返回值\n\ncallable和runnable都可以应用于executors。而thread类只支持runnable\n\n\n2、进程和线程一个进程可以包含多个线程，Java默认线程数：2个， main 和 GC 。\n对于Java而言，开启线程的方式为：Thread，Runnable，Callable\n\n问题：Java真的可以开启线程吗？\n\n否，我们来看一段代码：\npublic synchronized void start() &#123;       /**        * This method is not invoked for the main method thread or &quot;system&quot;        * group threads created/set up by the VM. Any new functionality added        * to this method in the future may have to also be added to the VM.        *        * A zero status value corresponds to state &quot;NEW&quot;.        */       if (threadStatus != 0)           throw new IllegalThreadStateException();       /* Notify the group that this thread is about to be started        * so that it can be added to the group&#x27;s list of threads        * and the group&#x27;s unstarted count can be decremented. */       group.add(this);       boolean started = false;       try &#123;           start0();           started = true;       &#125; finally &#123;           try &#123;               if (!started) &#123;                   group.threadStartFailed(this);               &#125;           &#125; catch (Throwable ignore) &#123;               /* do nothing. If start0 threw a Throwable then                 it will be passed up the call stack */           &#125;       &#125;   &#125;//本地方法，底层调用C++,Java无法直接硬件操作   private native void start0();\n\n\n并发，并行\n\n并发：多线程操作同一资源\n\n单CPU，线程间快速切换\n\n并行：\n\n多CPU，多线程同时进行\n\npublic class test &#123;    public static void main(String[] args) &#123;        //获取CPU核数        System.out.println(Runtime.getRuntime().availableProcessors());    &#125;&#125;\n\n线程有哪几个状态？\npublic enum State &#123;    //新生    NEW,    //运行    RUNNABLE,    BLOCKED,    WAITING,        //超时等待    TIMED_WAITING,    TERMINATED;&#125;\n\n\nwait&#x2F;sleep区别\n\n\n来自不同类\n\nwait &#x3D;&gt; Object\nsleep &#x3D; &gt; Thread\n\n锁的释放\n\nwait释放，wait不释放\n\n使用范围\n\nsleep可以在任何地方使用\n而wait只能用于同步代码快\n\n是否捕获异常\n\nwait不需要（&#x3D;&#x3D;但是所有线程都会捕获中断异常&#x3D;&#x3D;），而sleep必须捕获\n3、Lock锁\n传统synchronized\n\npackage juc;//多线程模拟售票（并发）public class ticketDemo &#123;    public static void main(String[] args) &#123;        Ticket ticket = new Ticket();        //并发：多线程操作同一个资源类，直接把资源丢进线程        //线程A        new Thread(()-&gt;&#123;            for (int i = 0; i &lt; 20; i++) &#123;                ticket.sale();                try &#123;                    Thread.sleep(100);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;A&quot;).start();        //线程B        new Thread(()-&gt;&#123;            for (int i = 0; i &lt; 20; i++) &#123;                ticket.sale();            &#125;        &#125;,&quot;B&quot;).start();    &#125;&#125;//资源类:属性和方法OOP//尽量不要在此处继承Runnable接口，降低耦合度class Ticket&#123;    //属性    private int num=20;    //方法    public synchronized void sale()&#123;        if(num&gt;0)        System.out.println(&quot;剩余票数为&quot; + (num--)+&quot;线程为&quot;+ Thread.currentThread().getName());    &#125;&#125;\n\n\nLock锁\n\npackage juc;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;//多线程模拟售票（并发）public class ticketDemo2 &#123;    public static void main(String[] args) &#123;        Ticket2 ticket = new Ticket2();        //并发：多线程操作同一个资源类，直接把资源丢进线程        //线程A        new Thread(()-&gt;&#123;            for (int i = 0; i &lt; 20; i++) &#123;                ticket.sale();                try &#123;                    Thread.sleep(100);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;A&quot;).start();                //线程B        new Thread(()-&gt;&#123;            for (int i = 0; i &lt; 20; i++) &#123;                ticket.sale();            &#125;        &#125;,&quot;B&quot;).start();    &#125;&#125;//Lock三部曲/** * 1.new ReentrantLock() * 2.lock.lock()加锁 * 3.finally =&gt; lock.unlock 解锁 */class Ticket2&#123;    //属性    private int num=20;   Lock lock = new ReentrantLock();    //方法    public void sale()&#123;        lock.lock();    //加锁        try &#123;        //业务代码            if (num &gt; 0)                System.out.println(&quot;剩余票数为&quot; + (num--) + &quot;线程为&quot; + Thread.currentThread().getName());        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;finally &#123;     //无论如何都要解锁            lock.unlock();        &#125;    &#125;&#125;\n\n&#x3D;&#x3D;synchronized与lock锁的区别&#x3D;&#x3D;\n\nsynchronized 内置的Java关键字，Lock是一个Java类\nsynchronized 无法判断锁的状态，lock可以判断是否获得锁\n前者自动释放锁，lock必须手动释放！如果不释放，将导致死锁！\nsynchroniezd无法获得锁将阻塞等待，lock则不会一直等待。\nsynchronized 可重入锁，不可中断，非公平，而Lock是可重入锁，可以判断锁，默认非公平（可修改）。\n\n\n可重入锁：可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。\n\n\nsynchronized适合锁少量的代码同步问题，lock适合锁大量的同步代码。\n\n&#x3D;&#x3D;锁是什么？如何判断锁是谁？&#x3D;&#x3D;\n4、生产者消费者问题三个步骤：等待 -&gt; 操作 -&gt; 通知\n\nsynchronized实现方案\nlock实现方案\n\n两者的区别是什么？\nsynchronized通过wait方法使线程阻塞，notify方法唤醒线程\n而lock则是通过await方法阻塞等待，signal唤醒，相比lock可支持定向唤醒某个线程（condition）\nCondition con1 = lock.newCondition()Condition con2 = lock.newCondition()con1.signal(); //指定唤醒\n\n注意：为防止虚假唤醒，在判断时，应当使用&#x3D;&#x3D;while&#x3D;&#x3D;\n5、八锁现象涉及到锁的八个问题。（注意同步关系）\n注意：在所有的锁中，如果是锁的对象中的某个方法或者属性，则表示对该对象加锁。\n而如果是对静态方法加锁，则表示对Class（模板）加锁，所有对静态属性或者静态方法加锁的行为都是同一把锁。\n6、CopyOnWriteArrayList(C\nArrayList的并发异常\n\nimport java.util.ArrayList;//list的并发异常ConcurrentModificationExceptionpublic class Listdemo &#123;    public static void main(String[] args) &#123;        ArrayList arrayList = new ArrayList();        for (int i = 0; i &lt; 100; i++) &#123;            new Thread(()-&gt;&#123;                arrayList.add(&quot;hello&quot;);            &#125;).start();        &#125;        System.out.println(arrayList);    &#125;&#125;\n\n\nException in thread “main” java.util.ConcurrentModificationException\n\n&#x3D;&#x3D;并发异常的解决方案：&#x3D;&#x3D;\n\n使用线程安全类Vector\n\n\nList arrayList = new Vector();\n\n\n使用工具类Collections\n\n\nList arrayList = Collections.synchronizedList(new ArrayList());\n\n\n&#x3D;&#x3D;CopyOnWriteArrayList（写入时复制）&#x3D;&#x3D;(读写分离)\n\n多个线程写入的时候，避免覆盖\n\nList arrayList = new CopyOnWriteArrayList();\n\n看底层代码：\npublic boolean add(E e) &#123;    synchronized (lock) &#123;        Object[] es = getArray();        int len = es.length;        es = Arrays.copyOf(es, len + 1);        es[len] = e;        setArray(es);        return true;    &#125;&#125;\n\n相比Vector不需要在读的时候加锁，写入时复制大大提高读取效率。（即读操作不需要进行同步）l（在开发中读比写频繁）\n看一下Vector的get方法如下\npublic synchronized E get(int index) &#123;    if (index &gt;= elementCount)        throw new ArrayIndexOutOfBoundsException(index);    return elementData(index);&#125;\n\n7、CopyOnWriteArraySetSet arraySet = new CopyOnWriteArraySet();\n\n8、ConcurrentHashMapHashMap在并发下put产生异常！\n      Map map = new HashMap();//并发HashMapMap map = new ConcurrentHashMap();      for (int i = 0; i &lt; 50; i++) &#123;          int finalI = i;          new Thread(()-&gt;&#123;              map.put(String.valueOf(finalI),&quot;world&quot;);          &#125;).start();      &#125;      System.out.println(map);  &#125;\n\n9、JUC常用辅助类1. CountDownLatch资源–\npackage juc;import java.util.concurrent.CountDownLatch;public class CountDownDemo &#123;    public static void main(String[] args) throws InterruptedException &#123;        //线程计数器        CountDownLatch countDownLatch = new CountDownLatch  (6);        for (int i = 0; i &lt; 6; i++) &#123;            int finalI = i;            new Thread(()-&gt;&#123;                countDownLatch.countDown();//计数器-1                //System.out.println(finalI);            &#125;).start();        &#125;        //判断是否归零,接着再执行下一步操作        countDownLatch.await();        System.out.println(countDownLatch.getCount());        System.out.println(&quot;close door&quot;);    &#125;&#125;\n\n2. CyclicBarrier资源++\n 线程计数器（集齐7颗龙珠触发操作）：指定个数线程执行完毕之后再执行操作\n3. Semaphere信号量同一时间只能有指定个线程执行（限流）\npackage juc;import java.util.concurrent.Semaphore;public class SemaphereDemo  &#123;    public static void main(String[] args) &#123;        //线程数量        Semaphore semaphore = new Semaphore(3);        for (int i = 0; i &lt; 5; i++) &#123;            new Thread(()-&gt;&#123;                //aquire()得到                try &#123;                    semaphore.acquire();                    System.out.println(Thread.currentThread().getName()+&quot; running&quot;);                    Thread.sleep(2000);                    System.out.println(Thread.currentThread().getName()+&quot; closed&quot;);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;finally &#123;                    semaphore.release();                &#125;            &#125;).start();        &#125;    &#125;&#125;\n\n\n原理： semaphore.acquire(); 获得，如果已满则等待\n​\t\t\tsemaphore.release(); 释放，会将当前信号量+1，然后唤醒等待线程\n\n作用：多个共享资源互斥使用，并发限流，控制最大线程数。\n10、读写锁ReadWriteLock\n11、BlockingQueue阻塞队列(接口)用处：多线程并发处理，线程池 。\n\n\n如何使用队列：\n四组API\n\n\n\n方式\n抛出异常\n有返回值，不抛出异常\n阻塞等待\n超时等待\n\n\n\n添加\nadd\noffer\nput\noffer\n\n\n移除\nremove\npoll\ntake\npoll\n\n\n检测队首\nelement\npeek\n-\n\n\n\npackage juc;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;/** * 1.抛出异常 */public class BlockDemo &#123;    public static void main(String[] args) &#123;        test1();    &#125;    public static void test1()&#123;        //队列大小        BlockingQueue blockingQueue = new ArrayBlockingQueue(2);        System.out.println(blockingQueue.add(&quot;a&quot;));        System.out.println(blockingQueue.add(&quot;b&quot;));        //System.out.println(blockingQueue.add(&quot;c&quot;));        //抛出异常IllegalStateException: Queue full        blockingQueue.remove();        blockingQueue.remove();        blockingQueue.remove();        //抛出异常NoSuchElementException    &#125;&#125;\n\n/** * 2.有返回值，不抛出异常 */public static void test2()&#123;    //队列大小    BlockingQueue blockingQueue = new ArrayBlockingQueue(2);        System.out.println(blockingQueue.offer(&quot;a&quot;));    System.out.println(blockingQueue.offer(&quot;b&quot;));    System.out.println(blockingQueue.offer(&quot;c&quot;));   //输出false             \tSystem.out.println(blockingQueue.peek());  //输出a        blockingQueue.poll();    blockingQueue.poll();    System.out.println(blockingQueue.poll());   //输出null&#125;\n\n/** *3.阻塞等待 */public static void test3() throws InterruptedException &#123;    //队列大小    BlockingQueue blockingQueue = new ArrayBlockingQueue(2);    blockingQueue.put(&quot;a&quot;);    blockingQueue.put(&quot;a&quot;);    //blockingQueue.put(&quot;a&quot;);   //阻塞等待    System.out.println(blockingQueue.take());    System.out.println(blockingQueue.take());    blockingQueue.take();  //阻塞&#125;\n\n/** *4.超时等待 */public static void test4() throws InterruptedException &#123;    //队列大小    BlockingQueue blockingQueue = new ArrayBlockingQueue(2);    blockingQueue.offer(&quot;a&quot;);    blockingQueue.offer(&quot;b&quot;);    blockingQueue.offer(&quot;c&quot;,2, TimeUnit.SECONDS);  //超时等待2秒    System.out.println(blockingQueue.poll());    System.out.println(blockingQueue.poll());    blockingQueue.poll(2,TimeUnit.SECONDS);&#125;\n\n12、同步队列SynchronousQueue（类）同步队列不存储元素，put了一个元素后，必须先take出来，否则无法put。\n13、&#x3D;&#x3D;线程池（重点）&#x3D;&#x3D;三大方法，7大参数，4种拒绝策略\n\n池化技术：事先准备好一些资源，有需要则来拿，用完还回去。\n\n程序运行的本质：占用系统资源！优化资源的使用！&#x3D;&gt;池化技术\n线程池、连接池、内存池….\n默认大小：2\n线程池好处：\n\n降低资源的消耗\n提高响应速度（不需要创建和销毁等浪费时间的操作）\n方便管理\n\n&#x3D;&#x3D;线程复用，控制最大并发数，管理线程&#x3D;&#x3D;\n\n3大方法\n\npackage juc;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;//Excutors 工具类、3大方法public class PoolDemo &#123;    public static void main(String[] args) &#123;        ExecutorService executorService = Executors.newSingleThreadExecutor();   //单个线程        ExecutorService executorService1 = Executors.newFixedThreadPool(5);  //创建一个固定线程池大小        ExecutorService executorService2 = Executors.newCachedThreadPool();   //可伸缩的线程池        //开启线程(使用线程池创建线程)      try &#123;          for (int i = 0; i &lt; 100; i++) &#123;              executorService1.execute(()-&gt;&#123;                  System.out.println(Thread.currentThread().getName()+&quot;已启动！&quot;);              &#125;);          &#125;      &#125;catch (Exception e)&#123;          e.printStackTrace();      &#125;finally &#123;          executorService1.shutdown();  //保证线程池用完关闭      &#125;    &#125;&#125;\n\n\n7大参数\n\n先来看看三大方法的源码：\n//方法一：创建单个线程public static ExecutorService newSingleThreadExecutor() &#123;    return new FinalizableDelegatedExecutorService        (new ThreadPoolExecutor(1, 1,                                0L, TimeUnit.MILLISECONDS,                                new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;//方法二：创建固定线程池大小public static ExecutorService newFixedThreadPool(int nThreads) &#123;    return new ThreadPoolExecutor(nThreads, nThreads,                                  0L, TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue&lt;Runnable&gt;());&#125;//方法三public static ExecutorService newCachedThreadPool() &#123;    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;());&#125;\n\n本质上：上述三种方法底层都是调用&#x3D;&#x3D;ThreadPoolExecutor&#x3D;&#x3D;方法！\n因此，我们来看看ThreadPoolExecutor方法：\npublic ThreadPoolExecutor(int corePoolSize,   //核心线程池大小（当前可用线程）                          int maximumPoolSize, //最大线程池大小                          long keepAliveTime,  //存活时间（线程最大等待时间）                          TimeUnit unit,       //存活时间单位                          BlockingQueue&lt;Runnable&gt; workQueue) &#123;   //阻塞队列    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,         Executors.defaultThreadFactory(), defaultHandler);   //线程工厂和拒绝策略（4种策略）&#125;\n\n阿里开发守则之并发：\n\n接下来我们看一下&#x3D;&#x3D;四大拒绝策略&#x3D;&#x3D;：\nnew ThreadPoolExecutor.AbortPolicy());//队列满了，最大线程为8，此时抛出RejectedExecutionException异常new ThreadPoolExecutor().DiscardPolicy()); //队列满，丢掉任务，不抛出异常new ThreadPoolExecutor().DiscardOldestPolicy()); //队列满，尝试和最早的线程竞争，竞争成功执行，失败丢弃不抛出异常new ThreadPoolExecutor().CallerRunsPolicy()); //哪来的去哪里，由调用线程处理\n\npackage juc;import java.util.concurrent.*;//Excutors 工具类、3大方法public class PoolDemo &#123;    public static void main(String[] args) &#123;        //自定义线程池        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(                2,                5,                3,                TimeUnit.SECONDS,                new ArrayBlockingQueue(3),   //最大承载线程为队列长度+最大线程池                Executors.defaultThreadFactory(),                new ThreadPoolExecutor.AbortPolicy());//队列满了，最大线程为8，此时抛出RejectedExecutionException异常                // new ThreadPoolExecutor().DiscardPolicy()); //队列满，丢掉任务，不抛出异常                //new ThreadPoolExecutor().DiscardOldestPolicy()); //队列满，尝试和最早的线程竞争，竞争成功执行，失败丢弃不抛出异常                //new ThreadPoolExecutor().CallerRunsPolicy()); //哪来的去哪里，由调用线程处理        //开启线程(使用线程池创建线程)      try &#123;          for (int i = 0; i &lt; 9; i++) &#123;              threadPoolExecutor.execute(()-&gt;&#123;                  System.out.println(Thread.currentThread().getName()+&quot;已启动！&quot;);              &#125;);          &#125;      &#125;catch (Exception e)&#123;          e.printStackTrace();      &#125;finally &#123;          threadPoolExecutor.shutdown();  //保证线程池用完关闭      &#125;    &#125;&#125;\n\n\n&#x3D;&#x3D;最大的线程池大小maximumPoolSize如何设置？&#x3D;&#x3D;\n\nCPU密集型与IO密集型\nmaximumPoolSize //最大线程池大小    1.CPU密集型，=CPU核数    2.IO密集型，&gt;IO任务线程数        Runtime.getRuntime().availableProcessors();  //获取处理器核数\n\n14、四大函数式接口（必须掌握）（java.util.function）新时代程序员必会：lambda表达式、链式编程、函数式接口、Stream流式计算\n（旧时代程序员：泛型、枚举、反射）\n\n函数式接口：只有一个方法的接口\n​\t作用：简化编程模型，在新版本的框架底层大量应用\n\n  @FunctionalInterfacepublic interface Runnable &#123;    public abstract void run();&#125;\n\n\n&#x3D;&#x3D;函数型接口&#x3D;&#x3D;\n\n\n\npackage juc;import java.util.function.Function;/** * 1.Function函数式接口 * 只要是函数式接口，都可用lambda表达式简化 */public class InterfaceDemo &#123;    public static void main(String[] args) &#123;        Function function = new Function&lt;String,String&gt;()&#123;            @Override            public String  apply(String o) &#123;                return o;            &#125;        &#125;;        //lambda表达式        Function function1 = str-&gt;&#123;            return str;        &#125;;        System.out.println(function.apply(&quot;hello&quot;));        System.out.println(function1.apply(&quot;world&quot;));    &#125;&#125;\n\n\n&#x3D;&#x3D;断定型接口&#x3D;&#x3D;\n\n@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123;    boolean test(T t);\n\n\n\npackage juc;import java.util.function.Predicate;public class PredictedDemo &#123;    public static void main(String[] args) &#123;        Predicate&lt;String&gt; predicate = new Predicate&lt;&gt;() &#123;            @Override            public boolean test(String s) &#123;                return s.isEmpty();            &#125;        &#125;;        //用lambda表达式简化        Predicate&lt;String&gt; predicate1 = str-&gt;&#123;            return str.isEmpty();        &#125;;        System.out.println(predicate.test(&quot;hello&quot;));        System.out.println(predicate1.test(&quot;hello&quot;));    &#125;&#125;\n\n\n&#x3D;&#x3D;消费型接口&#x3D;&#x3D;\n\n@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123;    void accept(T t);\n\n\n\npackage juc;import java.util.function.Consumer;/** * 3.消费型接口 * 只有一个输入参数 */public class ConsumerDemo  &#123;    public static void main(String[] args) &#123;        Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() &#123;            @Override            public void accept(String s) &#123;                System.out.println(s);            &#125;        &#125;;        //lambda表达式        Consumer&lt;String&gt; consumer1 = str-&gt;&#123;            System.out.println(str);        &#125;;        consumer.accept(&quot;hello&quot;);        consumer1.accept(&quot;world&quot;);    &#125;&#125;\n\n\n&#x3D;&#x3D;供给型接口&#x3D;&#x3D;\n\n@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123;    T get();\t//只有返回值类型，没有输入参数&#125;\n\npackage juc;import java.util.function.Supplier;/** * 4.供给型接口 * 没有输出参数，只有返回值 */public class SupplierDemo &#123;    public static void main(String[] args) &#123;        Supplier&lt;String&gt; stringSupplier = new Supplier&lt;String&gt;()&#123;            @Override            public String get() &#123;                return &quot;hello&quot;;            &#125;        &#125;;        //lambda表达式        Supplier&lt;String&gt; supplier = ()-&gt;&#123;            return &quot;world&quot;;        &#125;;        System.out.println(stringSupplier.get());        System.out.println(supplier.get());    &#125;&#125;\n\n15、JMMJava内存模型，是不存在的东西，只是概念和约定！\n例如：\n\n线程解锁前，必须把共享变量立刻刷回主存。\n线程加锁前，必须读取主存中的最新值到工内存。\n加锁和解锁是同一把锁。\n\npackage juc;public class JMMDemo &#123;    private static int num=0;    public static void main(String[] args)&#123;        new Thread(()-&gt;&#123;            while (num ==0)&#123;   //线程永远无法停止            &#125;        &#125;).start();        num=1;        System.out.println(num);        System.out.println(Thread.activeCount());    &#125;&#125;\n\n\n16、Volatile三大特性：\n\n可见性\n非原子性\n禁止指令重排(内存屏障)\n\n17、单例模式\n饿汉式\n\n//单例模式（饿汉式）public class Hungry &#123;    //构造方式为私有    private Hungry()&#123;    &#125;    private final static Hungry HUNGRY = new Hungry();  //已经生成了对象（饿汉式）    public static Hungry getInstance()&#123;        return HUNGRY;    &#125;&#125;\n\n\nDCL懒汉式\n\n package juc.singleDemo;public class LazyMan &#123;    private LazyMan()&#123;    &#125;    private volatile static LazyMan lazyMan;  //为何加volatile？防止指令重排    //双重检测，防止多线程产生问题    public static LazyMan getInstance()&#123;        if(lazyMan==null)&#123;            synchronized (LazyMan.class)&#123;   //锁住类Class，防止多线程创建对象                if(lazyMan==null)&#123;                    lazyMan= new LazyMan();    //不是一个原子操作，可能发生指令重排                    /**                     * 1.分配内存空间                     * 2.执行构造方法                     * 3.把对象指向该空间                     * 123顺序执行没问题，但如果132在第二步时进入第二个线程则会直接返回lazyMan，此时对象还未完成构造                     */                &#125;            &#125;        &#125;        return lazyMan;    &#125;&#125;\n\n18、CAS(与乐观锁原理相同)compareAndSet：比较当前工作内存中的值和主内存中的值，如果是期望值那么执行操作否则一直循环。\n缺点：\n1、循环耗时\n2、一次性只能保证一个共享变量的原子性\n3、ABA问题\npackage juc.singleDemo;import java.util.concurrent.atomic.AtomicInteger;public class CASDemmo &#123;    public static void main(String[] args) &#123;        AtomicInteger atomicInteger = new AtomicInteger(2022);        System.out.println(atomicInteger.get());        System.out.println(atomicInteger.getAndIncrement());        System.out.println(atomicInteger.compareAndSet(2022, 2023));   //false        System.out.println(atomicInteger.get());    &#125;&#125;\n\n\n  **&#x3D;&#x3D;CAS的ABA问题&#x3D;&#x3D;**：如果改变的是基本类型则没影响，但是如果改变的是引用类型，由于Java是值传递，虽然传递的值不变，但可能引用的对象已经发生改变。\n如何解决？原子引用！（带版本号的原子操作）\n19、java的Integer比较\n**&#x3D;&#x3D;注意&#x3D;&#x3D;**：&#x3D;&#x3D;所有相同类型的包装类对象之间的值比较，应该使用equals方法比较。&#x3D;&#x3D;–来自阿里巴巴java开发手册。\n\n例：\npublic static void main(String[] args)throws Exception&#123;    Integer a = -121;    Integer b = -121;    Integer c = 345;    Integer d = 345;    System.out.println(a.equals(b));    System.out.println(a == b);    System.out.println(c.equals(d));    System.out.println(c == d);&#125;\n\n打印结果为：\ntruetruetruefalse\n\nc和d的值都是345,为什么用&#x3D;&#x3D;和equals比较结果不一样呢？\n我们看下对象信息，注意对象地址：\n\n\nInteger值的比较有个坑：对于Integer var &#x3D; ?,&#x3D;&#x3D;在-128至127范围内的赋值， Integer 对象是在IntegerCache.cache 产生，会复用已有对象&#x3D;&#x3D;，这个区间内的 Integer 值可以直接使用&#x3D;&#x3D;进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象;所以，在上面，我们的c和d两个，虽然值是一样的，但是地址不一样。\n这是一个大坑，很多人会在项目中使用&#x3D;&#x3D;来比较Integer！强烈建议，必须使用equals来比较！\n20、可重入锁（递归锁）\n在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁\n\n也即是说，线程可以进入任何一个它已经拥有的锁所同步着的代码块\n\n\npackage juc.Lock;//可重入锁public class Demo01 &#123;    public static void main(String[] args) &#123;        Phone phone = new Phone();        //线程A        new Thread(()-&gt;&#123;            phone.call();        &#125;,&quot;A&quot;).start();        //线程B        new Thread(()-&gt;&#123;            phone.call();        &#125;,&quot;B&quot;).start();    &#125;&#125;class Phone&#123;    public synchronized void call()&#123;           System.out.println(Thread.currentThread().getName()+&quot;call&quot;);        send();   //这里也有锁，此处自动获得内层的锁    &#125;    public synchronized void send()&#123;        System.out.println(Thread.currentThread().getName()+&quot;send&quot;);    &#125;&#125;输出：AcallAsendBcallBsend\n\n","categories":["java"],"tags":["java","juc","并发编程"]},{"url":"/2022/04/12/Spring/","content":"\n\n"},{"title":"idea总是自动切换jdk","url":"/2022/05/12/idea%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2jdk/","content":"\n\n因为每次重启项目或者更新pom依赖时，idea都会自动切换jdk版本，因此可以在父pom里面加入如下代码：\n&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;            &lt;version&gt;3.1&lt;/version&gt;            &lt;configuration&gt;                &lt;source&gt;1.8&lt;/source&gt;                &lt;target&gt;1.8&lt;/target&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;\n\n","categories":["idea的jdk配置问题"],"tags":["idea配置"]}]